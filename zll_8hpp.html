<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>zll: include/zll.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">zll
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('zll_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">zll.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;concepts&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
</div>
<p><a href="zll_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1__vptr.html">zll::_vptr&lt; A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__base_1_1access.html">zll::ll_base&lt; Derived &gt;::access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access type to the header of <a class="el" href="structzll_1_1ll__base.html" title="CRTP base class for linked list nodes containing ll_header.">ll_base</a>.  <a href="structzll_1_1ll__base_1_1access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__base_1_1access.html">zll::sh_base&lt; Derived, Compare &gt;::access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__base.html">zll::ll_base&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for linked list nodes containing <code><a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a></code>.  <a href="structzll_1_1ll__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__const__iterator.html">zll::ll_const_iterator&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list const-iterator, needs just pointer to node.  <a href="structzll_1_1ll__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__header.html">zll::ll_header&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked-list header containing pointers to the next and previous elements or the list itself.  <a href="structzll_1_1ll__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__iterator.html">zll::ll_iterator&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list iterator, needs just pointer to node.  <a href="structzll_1_1ll__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__list.html">zll::ll_list&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning linked list container, expects nodes to contain <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a> as member.  <a href="structzll_1_1ll__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__base.html">zll::sh_base&lt; Derived, Compare &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__header.html">zll::sh_header&lt; T, Acc, Compare &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__heap.html">zll::sh_heap&lt; T, Acc, Compare &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacezll"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezll.html">zll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__nothrow__access.html">zll::_nothrow_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__nothrow__access__compare.html">zll::_nothrow_access_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__provides__ll__header.html">zll::_provides_ll_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__provides__sh__header.html">zll::_provides_sh_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad557a40b4b74453a753885c38a99630e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zll_8hpp.html#ad557a40b4b74453a753885c38a99630e">ZLL_ASSERT</a>(expr)&#160;&#160;&#160;( (void) ( ( expr ) ) )</td></tr>
<tr class="memdesc:ad557a40b4b74453a753885c38a99630e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License.  <a href="zll_8hpp.html#ad557a40b4b74453a753885c38a99630e">More...</a><br /></td></tr>
<tr class="separator:ad557a40b4b74453a753885c38a99630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1d61dbaf61de26105350353407fec4dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a1d61dbaf61de26105350353407fec4dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">zll::_ll_ptr</a> = _vptr&lt; T, ll_list&lt; T, Acc &gt; &gt;</td></tr>
<tr class="memdesc:a1d61dbaf61de26105350353407fec4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic ptr wrapper pointer either to <a class="el" href="structzll_1_1ll__list.html" title="Non-owning linked list container, expects nodes to contain ll_header as member.">ll_list</a> or node with <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a>.  <a href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">More...</a><br /></td></tr>
<tr class="separator:a1d61dbaf61de26105350353407fec4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4103d2220bdc7be9c33845fca16a88"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a9a4103d2220bdc7be9c33845fca16a88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">zll::_sh_ptr</a> = _vptr&lt; T, sh_heap&lt; T, Acc, Compare &gt; &gt;</td></tr>
<tr class="separator:a9a4103d2220bdc7be9c33845fca16a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5ef02179fbe75cb5d79304b47220f96d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a5ef02179fbe75cb5d79304b47220f96d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5ef02179fbe75cb5d79304b47220f96d">zll::_attach_left</a> (T &amp;parent, T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a5ef02179fbe75cb5d79304b47220f96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf804f85df1acb7b8da0bcabd0b7e8ed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </td></tr>
<tr class="memitem:adf804f85df1acb7b8da0bcabd0b7e8ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#adf804f85df1acb7b8da0bcabd0b7e8ed">zll::_attach_parent</a> (T &amp;node, _sh_ptr&lt; T, Acc, Compare &gt; p) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:adf804f85df1acb7b8da0bcabd0b7e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cd33deb6dedef29f3e39af230ad4b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a36cd33deb6dedef29f3e39af230ad4b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a36cd33deb6dedef29f3e39af230ad4b5">zll::_attach_right</a> (T &amp;parent, T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a36cd33deb6dedef29f3e39af230ad4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c1c4d9b83f05ff596a3a211977e99"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </td></tr>
<tr class="memitem:a763c1c4d9b83f05ff596a3a211977e99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a763c1c4d9b83f05ff596a3a211977e99">zll::_attach_top</a> (sh_heap&lt; T, Acc, Compare &gt; &amp;parent, T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a763c1c4d9b83f05ff596a3a211977e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b01c9d516b5bf6cbe015ac4b93fbc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a295b01c9d516b5bf6cbe015ac4b93fbc"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a295b01c9d516b5bf6cbe015ac4b93fbc">zll::_detach_left</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a295b01c9d516b5bf6cbe015ac4b93fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b88d1bc80ea55901a2442ae7db32b18"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a3b88d1bc80ea55901a2442ae7db32b18"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a3b88d1bc80ea55901a2442ae7db32b18">zll::_detach_parent</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a3b88d1bc80ea55901a2442ae7db32b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af648efdec4d274460dcca5defc183e1d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:af648efdec4d274460dcca5defc183e1d"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#af648efdec4d274460dcca5defc183e1d">zll::_detach_right</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:af648efdec4d274460dcca5defc183e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd36ad389c46eac793f18c5a00aa983"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </td></tr>
<tr class="memitem:a6cd36ad389c46eac793f18c5a00aa983"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6cd36ad389c46eac793f18c5a00aa983">zll::_detach_top</a> (sh_heap&lt; T, Acc, Compare &gt; &amp;parent) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a6cd36ad389c46eac793f18c5a00aa983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9eadfd87de5aa168bc390008668685"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a7c9eadfd87de5aa168bc390008668685"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a7c9eadfd87de5aa168bc390008668685">zll::_heap</a> (_sh_ptr&lt; T, Acc, Compare &gt; p) noexcept</td></tr>
<tr class="separator:a7c9eadfd87de5aa168bc390008668685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ee2786d9ecf29fa220db757b470f46"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a64ee2786d9ecf29fa220db757b470f46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a64ee2786d9ecf29fa220db757b470f46">zll::_list</a> (_ll_ptr&lt; T, Acc &gt; p) noexcept</td></tr>
<tr class="separator:a64ee2786d9ecf29fa220db757b470f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee5bb8c9ab624afd393f64acf5a628"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:abaee5bb8c9ab624afd393f64acf5a628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#abaee5bb8c9ab624afd393f64acf5a628">zll::_next_or_first_set</a> (_ll_ptr&lt; T, Acc &gt; p, _ll_ptr&lt; T, Acc &gt; n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:abaee5bb8c9ab624afd393f64acf5a628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f3d9775a158c210e833a1b0cd11527"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ab8f3d9775a158c210e833a1b0cd11527"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ab8f3d9775a158c210e833a1b0cd11527">zll::_node</a> (_ll_ptr&lt; T, Acc &gt; p) noexcept</td></tr>
<tr class="separator:ab8f3d9775a158c210e833a1b0cd11527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3d8080d9ae62d8bc470d715f7717fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a5e3d8080d9ae62d8bc470d715f7717fd"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5e3d8080d9ae62d8bc470d715f7717fd">zll::_node</a> (_sh_ptr&lt; T, Acc, Compare &gt; p) noexcept</td></tr>
<tr class="separator:a5e3d8080d9ae62d8bc470d715f7717fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d110bc2c6e4d316a398db52593d21c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a33d110bc2c6e4d316a398db52593d21c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a33d110bc2c6e4d316a398db52593d21c">zll::_prev_or_last_set</a> (_ll_ptr&lt; T, Acc &gt; p, _ll_ptr&lt; T, Acc &gt; n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a33d110bc2c6e4d316a398db52593d21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf971addd6e7635bba4603aa5fd7d38"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:aadf971addd6e7635bba4603aa5fd7d38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aadf971addd6e7635bba4603aa5fd7d38">zll::_replace_in_parent</a> (T &amp;node, T &amp;new_node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:aadf971addd6e7635bba4603aa5fd7d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e4c778914020642ccfc3ddd833a260"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare &gt; </td></tr>
<tr class="memitem:a91e4c778914020642ccfc3ddd833a260"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a91e4c778914020642ccfc3ddd833a260">zll::_sh_merge</a> (T &amp;left, T &amp;right, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a91e4c778914020642ccfc3ddd833a260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f11d2c10e737aac00294f05f0f352d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare &gt; </td></tr>
<tr class="memitem:a96f11d2c10e737aac00294f05f0f352d"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a96f11d2c10e737aac00294f05f0f352d">zll::_sh_merge_impl</a> (T &amp;left, T &amp;right, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a96f11d2c10e737aac00294f05f0f352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cd4fcb105442fbcbb359050182f988"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:aa9cd4fcb105442fbcbb359050182f988"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aa9cd4fcb105442fbcbb359050182f988">zll::_sh_pop</a> (T &amp;node, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:aa9cd4fcb105442fbcbb359050182f988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d418476eff4046b39fc5d0335ff6693"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a6d418476eff4046b39fc5d0335ff6693"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6d418476eff4046b39fc5d0335ff6693">zll::detach</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a6d418476eff4046b39fc5d0335ff6693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from existing list.  <a href="namespacezll.html#a6d418476eff4046b39fc5d0335ff6693">More...</a><br /></td></tr>
<tr class="separator:a6d418476eff4046b39fc5d0335ff6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639d609c33a126597e38011900c08364"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:a639d609c33a126597e38011900c08364"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a639d609c33a126597e38011900c08364">zll::detach</a> (T &amp;node, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a639d609c33a126597e38011900c08364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee72801f82d0cebea0f695436f422f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a5aee72801f82d0cebea0f695436f422f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5aee72801f82d0cebea0f695436f422f">zll::detach_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5aee72801f82d0cebea0f695436f422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches subrange [first, last] from the list.  <a href="namespacezll.html#a5aee72801f82d0cebea0f695436f422f">More...</a><br /></td></tr>
<tr class="separator:a5aee72801f82d0cebea0f695436f422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4686b548a6c2812e4ee2e6f9ab3ab8fa">zll::detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from list.  <a href="namespacezll.html#a4686b548a6c2812e4ee2e6f9ab3ab8fa">More...</a><br /></td></tr>
<tr class="separator:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1e5f7f94bac5fc728b19ee708f3fc2ff">zll::detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from heap.  <a href="namespacezll.html#a1e5f7f94bac5fc728b19ee708f3fc2ff">More...</a><br /></td></tr>
<tr class="separator:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0b9647befb868890b60caf39f3d293"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:aee0b9647befb868890b60caf39f3d293"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aee0b9647befb868890b60caf39f3d293">zll::detached_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aee0b9647befb868890b60caf39f3d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range is detached from list.  <a href="namespacezll.html#aee0b9647befb868890b60caf39f3d293">More...</a><br /></td></tr>
<tr class="separator:aee0b9647befb868890b60caf39f3d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ace8082eb072c3286742c3b17b825b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a2ace8082eb072c3286742c3b17b825b9"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a2ace8082eb072c3286742c3b17b825b9">zll::find_if_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:a2ace8082eb072c3286742c3b17b825b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found.  <a href="namespacezll.html#a2ace8082eb072c3286742c3b17b825b9">More...</a><br /></td></tr>
<tr class="separator:a2ace8082eb072c3286742c3b17b825b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8723bf61a7e944036fb5dfce168d70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a5b8723bf61a7e944036fb5dfce168d70"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5b8723bf61a7e944036fb5dfce168d70">zll::first_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5b8723bf61a7e944036fb5dfce168d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over predecessors of node <code>n</code> and return the first node in the list.  <a href="namespacezll.html#a5b8723bf61a7e944036fb5dfce168d70">More...</a><br /></td></tr>
<tr class="separator:a5b8723bf61a7e944036fb5dfce168d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55da35af7a7e04b1898f7562f8274b7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:ab55da35af7a7e04b1898f7562f8274b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ab55da35af7a7e04b1898f7562f8274b7">zll::for_each_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:ab55da35af7a7e04b1898f7562f8274b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node.  <a href="namespacezll.html#ab55da35af7a7e04b1898f7562f8274b7">More...</a><br /></td></tr>
<tr class="separator:ab55da35af7a7e04b1898f7562f8274b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a18cb8f77ce9ca47bc8d873ec2bda5a7a">zll::inorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a71541bac40e1e9feef56f551b0bbe9ce">zll::last_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a71541bac40e1e9feef56f551b0bbe9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over successors of node <code>n</code> and return the last node in the list.  <a href="namespacezll.html#a71541bac40e1e9feef56f551b0bbe9ce">More...</a><br /></td></tr>
<tr class="separator:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e37f363fceef88778368b5d5dc860"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a1d8e37f363fceef88778368b5d5dc860"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1d8e37f363fceef88778368b5d5dc860">zll::link_detached</a> (T &amp;n1, T &amp;n2, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a1d8e37f363fceef88778368b5d5dc860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c452ca25356a01e4ac1a88d341add"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:ad06c452ca25356a01e4ac1a88d341add"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ad06c452ca25356a01e4ac1a88d341add">zll::link_detached_as_first</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ad06c452ca25356a01e4ac1a88d341add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#ad06c452ca25356a01e4ac1a88d341add">More...</a><br /></td></tr>
<tr class="separator:ad06c452ca25356a01e4ac1a88d341add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c1bab91c3855c29f296a9899f43341"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a19c1bab91c3855c29f296a9899f43341"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a19c1bab91c3855c29f296a9899f43341">zll::link_detached_as_last</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a19c1bab91c3855c29f296a9899f43341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#a19c1bab91c3855c29f296a9899f43341">More...</a><br /></td></tr>
<tr class="separator:a19c1bab91c3855c29f296a9899f43341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528cd753e28cd0fab24c8ce781d7776c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a528cd753e28cd0fab24c8ce781d7776c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a528cd753e28cd0fab24c8ce781d7776c">zll::link_detached_as_next</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a528cd753e28cd0fab24c8ce781d7776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>.  <a href="namespacezll.html#a528cd753e28cd0fab24c8ce781d7776c">More...</a><br /></td></tr>
<tr class="separator:a528cd753e28cd0fab24c8ce781d7776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aaec58819ce3b46a79a6ba5beef9f2fc1">zll::link_detached_as_prev</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>.  <a href="namespacezll.html#aaec58819ce3b46a79a6ba5beef9f2fc1">More...</a><br /></td></tr>
<tr class="separator:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3735f9abc58f2c4a5775a9ee0008df7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a3735f9abc58f2c4a5775a9ee0008df7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a3735f9abc58f2c4a5775a9ee0008df7e">zll::link_detached_copy_of</a> (T &amp;node, T &amp;cpy, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a3735f9abc58f2c4a5775a9ee0008df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a60d848eba83fa0a8aa19aa4a6496328e">zll::link_group</a> (std::initializer_list&lt; T * &gt; nodes)</td></tr>
<tr class="memdesc:a60d848eba83fa0a8aa19aa4a6496328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link nodes in <code>nodes</code> in order as successors of each other.  <a href="namespacezll.html#a60d848eba83fa0a8aa19aa4a6496328e">More...</a><br /></td></tr>
<tr class="separator:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#abc80f9ef1f7cebd1cfb3d12751a72366">zll::link_range_as_next</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as successor of node <code>n</code>.  <a href="namespacezll.html#abc80f9ef1f7cebd1cfb3d12751a72366">More...</a><br /></td></tr>
<tr class="separator:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a86fc7485c5d05f2dc303cbb342d05eef">zll::link_range_as_prev</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a86fc7485c5d05f2dc303cbb342d05eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as predecessor of node <code>n</code>.  <a href="namespacezll.html#a86fc7485c5d05f2dc303cbb342d05eef">More...</a><br /></td></tr>
<tr class="separator:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a42243d44581d8f0ee1e9c18d4acf2184">zll::merge_ranges</a> (T &amp;lhf, T &amp;lhl, T &amp;rhf, T &amp;rhl, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(comp(lhf, rhf)))</td></tr>
<tr class="memdesc:a42243d44581d8f0ee1e9c18d4acf2184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two ranges [lhf, lhl] and [rhf, rhl] into one range.  <a href="namespacezll.html#a42243d44581d8f0ee1e9c18d4acf2184">More...</a><br /></td></tr>
<tr class="separator:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144697c395d7e039e0aca2a585fbe792"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a144697c395d7e039e0aca2a585fbe792"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a144697c395d7e039e0aca2a585fbe792">zll::move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a144697c395d7e039e0aca2a585fbe792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node.  <a href="namespacezll.html#a144697c395d7e039e0aca2a585fbe792">More...</a><br /></td></tr>
<tr class="separator:a144697c395d7e039e0aca2a585fbe792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a24b2449a29846b12ecb477ed4a52f8f0">zll::move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daf6432db70018790a23a5b9bad24a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a8daf6432db70018790a23a5b9bad24a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a8daf6432db70018790a23a5b9bad24a6">zll::postorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a8daf6432db70018790a23a5b9bad24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73348745e5791eb7557fd8367a7e14ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a73348745e5791eb7557fd8367a7e14ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a73348745e5791eb7557fd8367a7e14ff">zll::preorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a73348745e5791eb7557fd8367a7e14ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccc5e1d745179f3326f0ff913454176"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a1ccc5e1d745179f3326f0ff913454176"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1ccc5e1d745179f3326f0ff913454176">zll::range_qsort</a> (T &amp;first, T &amp;last, Compare &amp;&amp;cmp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(cmp(first, last)))</td></tr>
<tr class="memdesc:a1ccc5e1d745179f3326f0ff913454176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes.  <a href="namespacezll.html#a1ccc5e1d745179f3326f0ff913454176">More...</a><br /></td></tr>
<tr class="separator:a1ccc5e1d745179f3326f0ff913454176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Pred &gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4bd2dd1625cac198e1fc0e293555e9f0">zll::range_remove</a> (T &amp;first, T &amp;last, Pred &amp;&amp;p) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first)))</td></tr>
<tr class="memdesc:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a4bd2dd1625cac198e1fc0e293555e9f0">More...</a><br /></td></tr>
<tr class="separator:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34016023d1d718ae8bfb47426a3a7c39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a34016023d1d718ae8bfb47426a3a7c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a34016023d1d718ae8bfb47426a3a7c39">zll::range_reverse</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a34016023d1d718ae8bfb47426a3a7c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse order of nodes in the range [first, last].  <a href="namespacezll.html#a34016023d1d718ae8bfb47426a3a7c39">More...</a><br /></td></tr>
<tr class="separator:a34016023d1d718ae8bfb47426a3a7c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a0f5d6a98fc40a5b09ff7b6db2f55dff5">zll::range_unique</a> (T &amp;first, T &amp;last, BinPred &amp;&amp;p=std::equal_to&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first, last)))</td></tr>
<tr class="memdesc:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a0f5d6a98fc40a5b09ff7b6db2f55dff5">More...</a><br /></td></tr>
<tr class="separator:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a71983897a243ee29a1a0d1ce5f1ad236">zll::top_node_of</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad557a40b4b74453a753885c38a99630e" name="ad557a40b4b74453a753885c38a99630e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad557a40b4b74453a753885c38a99630e">&#9670;&#160;</a></span>ZLL_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZLL_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;( (void) ( ( expr ) ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIT License. </p>
<p >Copyright (c) 2024 koniarik</p>
<p >Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p >The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p >THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="zll_8hpp.html">zll.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
