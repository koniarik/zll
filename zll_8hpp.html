<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>zll: include/zll.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">zll
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('zll_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">zll.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;concepts&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
</div>
<p><a href="zll_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1__ll__ptr.html">zll::_ll_ptr&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic ptr wrapper pointer either to <a class="el" href="structzll_1_1ll__list.html" title="Non-owning linked list container, expects nodes to contain ll_header as member.">ll_list</a> or node with <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a>.  <a href="structzll_1_1__ll__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__base_1_1access.html">zll::ll_base&lt; Derived &gt;::access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access type to the header of <a class="el" href="structzll_1_1ll__base.html" title="CRTP base class for linked list nodes containing ll_header.">ll_base</a>.  <a href="structzll_1_1ll__base_1_1access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__base.html">zll::ll_base&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for linked list nodes containing <code><a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a></code>.  <a href="structzll_1_1ll__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__const__iterator.html">zll::ll_const_iterator&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list const-iterator, needs just pointer to node.  <a href="structzll_1_1ll__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__header.html">zll::ll_header&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked-list header containing pointers to the next and previous elements or the list itself.  <a href="structzll_1_1ll__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__iterator.html">zll::ll_iterator&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list iterator, needs just pointer to node.  <a href="structzll_1_1ll__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__list.html">zll::ll_list&lt; T, Acc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning linked list container, expects nodes to contain <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a> as member.  <a href="structzll_1_1ll__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacezll"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezll.html">zll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__nothrow__access.html">zll::_nothrow_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad557a40b4b74453a753885c38a99630e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zll_8hpp.html#ad557a40b4b74453a753885c38a99630e">ZLL_ASSERT</a>(expr)&#160;&#160;&#160;( (void) ( ( expr ) ) )</td></tr>
<tr class="memdesc:ad557a40b4b74453a753885c38a99630e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License.  <a href="zll_8hpp.html#ad557a40b4b74453a753885c38a99630e">More...</a><br /></td></tr>
<tr class="separator:ad557a40b4b74453a753885c38a99630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a902aabb693f053efc15f182c78ad3a24"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a902aabb693f053efc15f182c78ad3a24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a902aabb693f053efc15f182c78ad3a24">zll::_next_or_first_set</a> (_ll_ptr&lt; T, Acc &gt; p, _ll_ptr&lt; T, Acc &gt; n)</td></tr>
<tr class="separator:a902aabb693f053efc15f182c78ad3a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2681e264ccf581ce0999c457afdf1ec3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a2681e264ccf581ce0999c457afdf1ec3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a2681e264ccf581ce0999c457afdf1ec3">zll::_prev_or_last_set</a> (_ll_ptr&lt; T, Acc &gt; p, _ll_ptr&lt; T, Acc &gt; n)</td></tr>
<tr class="separator:a2681e264ccf581ce0999c457afdf1ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dcff9e0b17b45d0d40570246654473"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ae4dcff9e0b17b45d0d40570246654473"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ae4dcff9e0b17b45d0d40570246654473">zll::detach</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ae4dcff9e0b17b45d0d40570246654473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from existing list.  <a href="namespacezll.html#ae4dcff9e0b17b45d0d40570246654473">More...</a><br /></td></tr>
<tr class="separator:ae4dcff9e0b17b45d0d40570246654473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6864cb6b66d1c75e2b3fddeae15f3a57">zll::detach_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches subrange [first, last] from the list.  <a href="namespacezll.html#a6864cb6b66d1c75e2b3fddeae15f3a57">More...</a><br /></td></tr>
<tr class="separator:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef80f00bd49c5c620b58e36c3974457f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:aef80f00bd49c5c620b58e36c3974457f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aef80f00bd49c5c620b58e36c3974457f">zll::detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aef80f00bd49c5c620b58e36c3974457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from list.  <a href="namespacezll.html#aef80f00bd49c5c620b58e36c3974457f">More...</a><br /></td></tr>
<tr class="separator:aef80f00bd49c5c620b58e36c3974457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ade6b16aa7d1c22a250c2ecd27fe0a86e">zll::detached_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range is detached from list.  <a href="namespacezll.html#ade6b16aa7d1c22a250c2ecd27fe0a86e">More...</a><br /></td></tr>
<tr class="separator:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ac212469572388c29b3e9f5a4d7c1fdf8">zll::find_if_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found.  <a href="namespacezll.html#ac212469572388c29b3e9f5a4d7c1fdf8">More...</a><br /></td></tr>
<tr class="separator:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdb72bff3b75e7aefe1062753b620a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a5fdb72bff3b75e7aefe1062753b620a8"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5fdb72bff3b75e7aefe1062753b620a8">zll::first_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5fdb72bff3b75e7aefe1062753b620a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over predecessors of node <code>n</code> and return the first node in the list.  <a href="namespacezll.html#a5fdb72bff3b75e7aefe1062753b620a8">More...</a><br /></td></tr>
<tr class="separator:a5fdb72bff3b75e7aefe1062753b620a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6613e379d2956adc2bdb9cd36e9c7d66">zll::for_each_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node.  <a href="namespacezll.html#a6613e379d2956adc2bdb9cd36e9c7d66">More...</a><br /></td></tr>
<tr class="separator:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#acb3d49ccfafa31e26f41cd3fc6d47772">zll::last_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over successors of node <code>n</code> and return the last node in the list.  <a href="namespacezll.html#acb3d49ccfafa31e26f41cd3fc6d47772">More...</a><br /></td></tr>
<tr class="separator:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab89b9b86e5214f8906941bcaec83da9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:aab89b9b86e5214f8906941bcaec83da9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aab89b9b86e5214f8906941bcaec83da9">zll::link_detached_as_first</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aab89b9b86e5214f8906941bcaec83da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#aab89b9b86e5214f8906941bcaec83da9">More...</a><br /></td></tr>
<tr class="separator:aab89b9b86e5214f8906941bcaec83da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0350a06962c27062bcebb2c0c8167d74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a0350a06962c27062bcebb2c0c8167d74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a0350a06962c27062bcebb2c0c8167d74">zll::link_detached_as_last</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a0350a06962c27062bcebb2c0c8167d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#a0350a06962c27062bcebb2c0c8167d74">More...</a><br /></td></tr>
<tr class="separator:a0350a06962c27062bcebb2c0c8167d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1247532b992ea8e554c193e211fb3d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a4e1247532b992ea8e554c193e211fb3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4e1247532b992ea8e554c193e211fb3d">zll::link_detached_as_next</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a4e1247532b992ea8e554c193e211fb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>.  <a href="namespacezll.html#a4e1247532b992ea8e554c193e211fb3d">More...</a><br /></td></tr>
<tr class="separator:a4e1247532b992ea8e554c193e211fb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a2de4d8e9874c04a9bfe0dd00234f93e4">zll::link_detached_as_prev</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>.  <a href="namespacezll.html#a2de4d8e9874c04a9bfe0dd00234f93e4">More...</a><br /></td></tr>
<tr class="separator:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89316c1e8467fd4bfc495ab4de053769"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a89316c1e8467fd4bfc495ab4de053769"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a89316c1e8467fd4bfc495ab4de053769">zll::link_group</a> (std::initializer_list&lt; T * &gt; nodes)</td></tr>
<tr class="memdesc:a89316c1e8467fd4bfc495ab4de053769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link nodes in <code>nodes</code> in order as successors of each other.  <a href="namespacezll.html#a89316c1e8467fd4bfc495ab4de053769">More...</a><br /></td></tr>
<tr class="separator:a89316c1e8467fd4bfc495ab4de053769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ac5877c8bc62c1063c1ed9f27e6119a41">zll::link_range_as_next</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as successor of node <code>n</code>.  <a href="namespacezll.html#ac5877c8bc62c1063c1ed9f27e6119a41">More...</a><br /></td></tr>
<tr class="separator:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80391f29fde57995ac9157c87caa4460"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a80391f29fde57995ac9157c87caa4460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a80391f29fde57995ac9157c87caa4460">zll::link_range_as_prev</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a80391f29fde57995ac9157c87caa4460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as predecessor of node <code>n</code>.  <a href="namespacezll.html#a80391f29fde57995ac9157c87caa4460">More...</a><br /></td></tr>
<tr class="separator:a80391f29fde57995ac9157c87caa4460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ad32d42d17d26dda04afa5b9e335eb6ea">zll::merge_ranges</a> (T &amp;lhf, T &amp;lhl, T &amp;rhf, T &amp;rhl, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(comp(lhf, rhf)))</td></tr>
<tr class="memdesc:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two ranges [lhf, lhl] and [rhf, rhl] into one range.  <a href="namespacezll.html#ad32d42d17d26dda04afa5b9e335eb6ea">More...</a><br /></td></tr>
<tr class="separator:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a8a73a71d27040e0f6a8d2619cabf76d3">zll::move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node.  <a href="namespacezll.html#a8a73a71d27040e0f6a8d2619cabf76d3">More...</a><br /></td></tr>
<tr class="separator:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bf2fc153f8a30aa027191eb90f6694"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a16bf2fc153f8a30aa027191eb90f6694"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a16bf2fc153f8a30aa027191eb90f6694">zll::range_qsort</a> (T &amp;first, T &amp;last, Compare &amp;&amp;cmp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(cmp(first, last)))</td></tr>
<tr class="memdesc:a16bf2fc153f8a30aa027191eb90f6694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes.  <a href="namespacezll.html#a16bf2fc153f8a30aa027191eb90f6694">More...</a><br /></td></tr>
<tr class="separator:a16bf2fc153f8a30aa027191eb90f6694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Pred &gt; </td></tr>
<tr class="memitem:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a27dbbb13d3c436148808c9f3d4d0dde0">zll::range_remove</a> (T &amp;first, T &amp;last, Pred &amp;&amp;p) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first)))</td></tr>
<tr class="memdesc:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a27dbbb13d3c436148808c9f3d4d0dde0">More...</a><br /></td></tr>
<tr class="separator:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a7d1b678ba2de19ece9bbec0ebad0c27d">zll::range_reverse</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse order of nodes in the range [first, last].  <a href="namespacezll.html#a7d1b678ba2de19ece9bbec0ebad0c27d">More...</a><br /></td></tr>
<tr class="separator:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841530e9ed4b2ff0498a15e415d39004"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a841530e9ed4b2ff0498a15e415d39004"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a841530e9ed4b2ff0498a15e415d39004">zll::range_unique</a> (T &amp;first, T &amp;last, BinPred &amp;&amp;p=std::equal_to&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first, last)))</td></tr>
<tr class="memdesc:a841530e9ed4b2ff0498a15e415d39004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a841530e9ed4b2ff0498a15e415d39004">More...</a><br /></td></tr>
<tr class="separator:a841530e9ed4b2ff0498a15e415d39004"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad557a40b4b74453a753885c38a99630e" name="ad557a40b4b74453a753885c38a99630e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad557a40b4b74453a753885c38a99630e">&#9670;&#160;</a></span>ZLL_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZLL_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;( (void) ( ( expr ) ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIT License. </p>
<p >Copyright (c) 2024 koniarik</p>
<p >Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p >The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p >THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="zll_8hpp.html">zll.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
