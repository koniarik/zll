<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>zll: zll Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">zll
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacezll.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">zll Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic ptr wrapper pointer either to <a class="el" href="structzll_1_1ll__list.html" title="Non-owning linked list container, expects nodes to contain ll_header as member.">ll_list</a> or node with <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a>.  <a href="structzll_1_1__ll__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__base.html">ll_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for linked list nodes containing <code><a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a></code>.  <a href="structzll_1_1ll__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__const__iterator.html">ll_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list const-iterator, needs just pointer to node.  <a href="structzll_1_1ll__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__header.html">ll_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked-list header containing pointers to the next and previous elements or the list itself.  <a href="structzll_1_1ll__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__iterator.html">ll_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list iterator, needs just pointer to node.  <a href="structzll_1_1ll__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__list.html">ll_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning linked list container, expects nodes to contain <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a> as member.  <a href="structzll_1_1ll__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__nothrow__access.html">_nothrow_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a902aabb693f053efc15f182c78ad3a24"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a902aabb693f053efc15f182c78ad3a24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a902aabb693f053efc15f182c78ad3a24">_next_or_first_set</a> (<a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt; p, <a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt; n)</td></tr>
<tr class="separator:a902aabb693f053efc15f182c78ad3a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2681e264ccf581ce0999c457afdf1ec3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a2681e264ccf581ce0999c457afdf1ec3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a2681e264ccf581ce0999c457afdf1ec3">_prev_or_last_set</a> (<a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt; p, <a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt; n)</td></tr>
<tr class="separator:a2681e264ccf581ce0999c457afdf1ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dcff9e0b17b45d0d40570246654473"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ae4dcff9e0b17b45d0d40570246654473"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ae4dcff9e0b17b45d0d40570246654473">detach</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ae4dcff9e0b17b45d0d40570246654473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from existing list.  <a href="namespacezll.html#ae4dcff9e0b17b45d0d40570246654473">More...</a><br /></td></tr>
<tr class="separator:ae4dcff9e0b17b45d0d40570246654473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6864cb6b66d1c75e2b3fddeae15f3a57">detach_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches subrange [first, last] from the list.  <a href="namespacezll.html#a6864cb6b66d1c75e2b3fddeae15f3a57">More...</a><br /></td></tr>
<tr class="separator:a6864cb6b66d1c75e2b3fddeae15f3a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef80f00bd49c5c620b58e36c3974457f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:aef80f00bd49c5c620b58e36c3974457f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aef80f00bd49c5c620b58e36c3974457f">detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aef80f00bd49c5c620b58e36c3974457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from list.  <a href="namespacezll.html#aef80f00bd49c5c620b58e36c3974457f">More...</a><br /></td></tr>
<tr class="separator:aef80f00bd49c5c620b58e36c3974457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ade6b16aa7d1c22a250c2ecd27fe0a86e">detached_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range is detached from list.  <a href="namespacezll.html#ade6b16aa7d1c22a250c2ecd27fe0a86e">More...</a><br /></td></tr>
<tr class="separator:ade6b16aa7d1c22a250c2ecd27fe0a86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ac212469572388c29b3e9f5a4d7c1fdf8">find_if_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found.  <a href="namespacezll.html#ac212469572388c29b3e9f5a4d7c1fdf8">More...</a><br /></td></tr>
<tr class="separator:ac212469572388c29b3e9f5a4d7c1fdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdb72bff3b75e7aefe1062753b620a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a5fdb72bff3b75e7aefe1062753b620a8"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5fdb72bff3b75e7aefe1062753b620a8">first_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5fdb72bff3b75e7aefe1062753b620a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over predecessors of node <code>n</code> and return the first node in the list.  <a href="namespacezll.html#a5fdb72bff3b75e7aefe1062753b620a8">More...</a><br /></td></tr>
<tr class="separator:a5fdb72bff3b75e7aefe1062753b620a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6613e379d2956adc2bdb9cd36e9c7d66">for_each_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node.  <a href="namespacezll.html#a6613e379d2956adc2bdb9cd36e9c7d66">More...</a><br /></td></tr>
<tr class="separator:a6613e379d2956adc2bdb9cd36e9c7d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#acb3d49ccfafa31e26f41cd3fc6d47772">last_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over successors of node <code>n</code> and return the last node in the list.  <a href="namespacezll.html#acb3d49ccfafa31e26f41cd3fc6d47772">More...</a><br /></td></tr>
<tr class="separator:acb3d49ccfafa31e26f41cd3fc6d47772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab89b9b86e5214f8906941bcaec83da9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:aab89b9b86e5214f8906941bcaec83da9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aab89b9b86e5214f8906941bcaec83da9">link_detached_as_first</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aab89b9b86e5214f8906941bcaec83da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#aab89b9b86e5214f8906941bcaec83da9">More...</a><br /></td></tr>
<tr class="separator:aab89b9b86e5214f8906941bcaec83da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0350a06962c27062bcebb2c0c8167d74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a0350a06962c27062bcebb2c0c8167d74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a0350a06962c27062bcebb2c0c8167d74">link_detached_as_last</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a0350a06962c27062bcebb2c0c8167d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#a0350a06962c27062bcebb2c0c8167d74">More...</a><br /></td></tr>
<tr class="separator:a0350a06962c27062bcebb2c0c8167d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1247532b992ea8e554c193e211fb3d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a4e1247532b992ea8e554c193e211fb3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4e1247532b992ea8e554c193e211fb3d">link_detached_as_next</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a4e1247532b992ea8e554c193e211fb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>.  <a href="namespacezll.html#a4e1247532b992ea8e554c193e211fb3d">More...</a><br /></td></tr>
<tr class="separator:a4e1247532b992ea8e554c193e211fb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a2de4d8e9874c04a9bfe0dd00234f93e4">link_detached_as_prev</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>.  <a href="namespacezll.html#a2de4d8e9874c04a9bfe0dd00234f93e4">More...</a><br /></td></tr>
<tr class="separator:a2de4d8e9874c04a9bfe0dd00234f93e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89316c1e8467fd4bfc495ab4de053769"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a89316c1e8467fd4bfc495ab4de053769"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a89316c1e8467fd4bfc495ab4de053769">link_group</a> (std::initializer_list&lt; T * &gt; nodes)</td></tr>
<tr class="memdesc:a89316c1e8467fd4bfc495ab4de053769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link nodes in <code>nodes</code> in order as successors of each other.  <a href="namespacezll.html#a89316c1e8467fd4bfc495ab4de053769">More...</a><br /></td></tr>
<tr class="separator:a89316c1e8467fd4bfc495ab4de053769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ac5877c8bc62c1063c1ed9f27e6119a41">link_range_as_next</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as successor of node <code>n</code>.  <a href="namespacezll.html#ac5877c8bc62c1063c1ed9f27e6119a41">More...</a><br /></td></tr>
<tr class="separator:ac5877c8bc62c1063c1ed9f27e6119a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80391f29fde57995ac9157c87caa4460"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a80391f29fde57995ac9157c87caa4460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a80391f29fde57995ac9157c87caa4460">link_range_as_prev</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a80391f29fde57995ac9157c87caa4460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as predecessor of node <code>n</code>.  <a href="namespacezll.html#a80391f29fde57995ac9157c87caa4460">More...</a><br /></td></tr>
<tr class="separator:a80391f29fde57995ac9157c87caa4460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ad32d42d17d26dda04afa5b9e335eb6ea">merge_ranges</a> (T &amp;lhf, T &amp;lhl, T &amp;rhf, T &amp;rhl, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(comp(lhf, rhf)))</td></tr>
<tr class="memdesc:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two ranges [lhf, lhl] and [rhf, rhl] into one range.  <a href="namespacezll.html#ad32d42d17d26dda04afa5b9e335eb6ea">More...</a><br /></td></tr>
<tr class="separator:ad32d42d17d26dda04afa5b9e335eb6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a8a73a71d27040e0f6a8d2619cabf76d3">move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node.  <a href="namespacezll.html#a8a73a71d27040e0f6a8d2619cabf76d3">More...</a><br /></td></tr>
<tr class="separator:a8a73a71d27040e0f6a8d2619cabf76d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bf2fc153f8a30aa027191eb90f6694"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a16bf2fc153f8a30aa027191eb90f6694"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a16bf2fc153f8a30aa027191eb90f6694">range_qsort</a> (T &amp;first, T &amp;last, Compare &amp;&amp;cmp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(cmp(first, last)))</td></tr>
<tr class="memdesc:a16bf2fc153f8a30aa027191eb90f6694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes.  <a href="namespacezll.html#a16bf2fc153f8a30aa027191eb90f6694">More...</a><br /></td></tr>
<tr class="separator:a16bf2fc153f8a30aa027191eb90f6694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Pred &gt; </td></tr>
<tr class="memitem:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a27dbbb13d3c436148808c9f3d4d0dde0">range_remove</a> (T &amp;first, T &amp;last, Pred &amp;&amp;p) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first)))</td></tr>
<tr class="memdesc:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a27dbbb13d3c436148808c9f3d4d0dde0">More...</a><br /></td></tr>
<tr class="separator:a27dbbb13d3c436148808c9f3d4d0dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a7d1b678ba2de19ece9bbec0ebad0c27d">range_reverse</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse order of nodes in the range [first, last].  <a href="namespacezll.html#a7d1b678ba2de19ece9bbec0ebad0c27d">More...</a><br /></td></tr>
<tr class="separator:a7d1b678ba2de19ece9bbec0ebad0c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841530e9ed4b2ff0498a15e415d39004"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a841530e9ed4b2ff0498a15e415d39004"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a841530e9ed4b2ff0498a15e415d39004">range_unique</a> (T &amp;first, T &amp;last, BinPred &amp;&amp;p=std::equal_to&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first, last)))</td></tr>
<tr class="memdesc:a841530e9ed4b2ff0498a15e415d39004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a841530e9ed4b2ff0498a15e415d39004">More...</a><br /></td></tr>
<tr class="separator:a841530e9ed4b2ff0498a15e415d39004"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a902aabb693f053efc15f182c78ad3a24" name="a902aabb693f053efc15f182c78ad3a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902aabb693f053efc15f182c78ad3a24">&#9670;&#160;</a></span>_next_or_first_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zll::_next_or_first_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2681e264ccf581ce0999c457afdf1ec3" name="a2681e264ccf581ce0999c457afdf1ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2681e264ccf581ce0999c457afdf1ec3">&#9670;&#160;</a></span>_prev_or_last_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zll::_prev_or_last_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzll_1_1__ll__ptr.html">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4dcff9e0b17b45d0d40570246654473" name="ae4dcff9e0b17b45d0d40570246654473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dcff9e0b17b45d0d40570246654473">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlink a node from existing list. </p>
<p >Previous or following node are linked together instead. Node itself does not keep any connections. </p>

</div>
</div>
<a id="a6864cb6b66d1c75e2b3fddeae15f3a57" name="a6864cb6b66d1c75e2b3fddeae15f3a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6864cb6b66d1c75e2b3fddeae15f3a57">&#9670;&#160;</a></span>detach_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach_range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches subrange [first, last] from the list. </p>
<p >The range is not linked to any other node after detachment. Successor of <code>last</code> and predecessor of <code>first</code> are linked together. </p>

</div>
</div>
<a id="aef80f00bd49c5c620b58e36c3974457f" name="aef80f00bd49c5c620b58e36c3974457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef80f00bd49c5c620b58e36c3974457f">&#9670;&#160;</a></span>detached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is detached from list. </p>

</div>
</div>
<a id="ade6b16aa7d1c22a250c2ecd27fe0a86e" name="ade6b16aa7d1c22a250c2ecd27fe0a86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6b16aa7d1c22a250c2ecd27fe0a86e">&#9670;&#160;</a></span>detached_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached_range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the range is detached from list. </p>

</div>
</div>
<a id="ac212469572388c29b3e9f5a4d7c1fdf8" name="ac212469572388c29b3e9f5a4d7c1fdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac212469572388c29b3e9f5a4d7c1fdf8">&#9670;&#160;</a></span>find_if_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * zll::find_if_node </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found. </p>
<p >Return pointer to such node, nullptr otherwise.</p>
<p >The order of the nodes is: predecessors, <code>n</code>, successors. </p>

</div>
</div>
<a id="a5fdb72bff3b75e7aefe1062753b620a8" name="a5fdb72bff3b75e7aefe1062753b620a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdb72bff3b75e7aefe1062753b620a8">&#9670;&#160;</a></span>first_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::first_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over predecessors of node <code>n</code> and return the first node in the list. </p>

</div>
</div>
<a id="a6613e379d2956adc2bdb9cd36e9c7d66" name="a6613e379d2956adc2bdb9cd36e9c7d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6613e379d2956adc2bdb9cd36e9c7d66">&#9670;&#160;</a></span>for_each_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::for_each_node </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node. </p>
<p >The order of the nodes is: predecessors, <code>n</code>, successors. </p>

</div>
</div>
<a id="acb3d49ccfafa31e26f41cd3fc6d47772" name="acb3d49ccfafa31e26f41cd3fc6d47772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3d49ccfafa31e26f41cd3fc6d47772">&#9670;&#160;</a></span>last_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::last_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over successors of node <code>n</code> and return the last node in the list. </p>

</div>
</div>
<a id="aab89b9b86e5214f8906941bcaec83da9" name="aab89b9b86e5214f8906941bcaec83da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab89b9b86e5214f8906941bcaec83da9">&#9670;&#160;</a></span>link_detached_as_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_first </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a0350a06962c27062bcebb2c0c8167d74" name="a0350a06962c27062bcebb2c0c8167d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0350a06962c27062bcebb2c0c8167d74">&#9670;&#160;</a></span>link_detached_as_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_last </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a4e1247532b992ea8e554c193e211fb3d" name="a4e1247532b992ea8e554c193e211fb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1247532b992ea8e554c193e211fb3d">&#9670;&#160;</a></span>link_detached_as_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_next </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a2de4d8e9874c04a9bfe0dd00234f93e4" name="a2de4d8e9874c04a9bfe0dd00234f93e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de4d8e9874c04a9bfe0dd00234f93e4">&#9670;&#160;</a></span>link_detached_as_prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_prev </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a89316c1e8467fd4bfc495ab4de053769" name="a89316c1e8467fd4bfc495ab4de053769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89316c1e8467fd4bfc495ab4de053769">&#9670;&#160;</a></span>link_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_group </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T * &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link nodes in <code>nodes</code> in order as successors of each other. </p>
<p >Undefined behavior if any of the nodes is not detached. </p>

</div>
</div>
<a id="ac5877c8bc62c1063c1ed9f27e6119a41" name="ac5877c8bc62c1063c1ed9f27e6119a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5877c8bc62c1063c1ed9f27e6119a41">&#9670;&#160;</a></span>link_range_as_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_range_as_next </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached range [first, last] as successor of node <code>n</code>. </p>
<p >Undefined behavior if sublist [first, last] is not detached. The range is linked as successor of <code>n</code> and the last element of the range is linked as predecessor of previous <code>n</code> successor. </p>

</div>
</div>
<a id="a80391f29fde57995ac9157c87caa4460" name="a80391f29fde57995ac9157c87caa4460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80391f29fde57995ac9157c87caa4460">&#9670;&#160;</a></span>link_range_as_prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_range_as_prev </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached range [first, last] as predecessor of node <code>n</code>. </p>
<p >Undefined behavior if sublist [first, last] is not detached. The range is linked as predecessor of <code>n</code> and the first element of the range is linked as successor of previous <code>n</code> predecessor. </p>

</div>
</div>
<a id="ad32d42d17d26dda04afa5b9e335eb6ea" name="ad32d42d17d26dda04afa5b9e335eb6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32d42d17d26dda04afa5b9e335eb6ea">&#9670;&#160;</a></span>merge_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T *, T * &gt; zll::merge_ranges </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge two ranges [lhf, lhl] and [rhf, rhl] into one range. </p>
<p >Uses <code>comp</code> to determine the order of the elements in the resulting range. Pointers to the first and last elements of the resulting range are returned. </p>

</div>
</div>
<a id="a8a73a71d27040e0f6a8d2619cabf76d3" name="a8a73a71d27040e0f6a8d2619cabf76d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a73a71d27040e0f6a8d2619cabf76d3">&#9670;&#160;</a></span>move_from_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::move_from_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node. </p>
<p >Can be used to implement move semantics of custom nodes. Undefined behavior if <code>to</code> is not detached. </p>

</div>
</div>
<a id="a16bf2fc153f8a30aa027191eb90f6694" name="a16bf2fc153f8a30aa027191eb90f6694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bf2fc153f8a30aa027191eb90f6694">&#9670;&#160;</a></span>range_qsort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::range_qsort </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes. </p>

</div>
</div>
<a id="a27dbbb13d3c436148808c9f3d4d0dde0" name="a27dbbb13d3c436148808c9f3d4d0dde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dbbb13d3c436148808c9f3d4d0dde0">&#9670;&#160;</a></span>range_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t zll::range_remove </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes in the range [first, last] for which <code>p</code> returns true. </p>
<p >Returns the number of removed nodes. </p>

</div>
</div>
<a id="a7d1b678ba2de19ece9bbec0ebad0c27d" name="a7d1b678ba2de19ece9bbec0ebad0c27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1b678ba2de19ece9bbec0ebad0c27d">&#9670;&#160;</a></span>range_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::range_reverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse order of nodes in the range [first, last]. </p>
<p >The first node in the range will become the last node and the last node will become the first node. </p>

</div>
</div>
<a id="a841530e9ed4b2ff0498a15e415d39004" name="a841530e9ed4b2ff0498a15e415d39004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841530e9ed4b2ff0498a15e415d39004">&#9670;&#160;</a></span>range_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t zll::range_unique </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinPred &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em> = <code>std::equal_to&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true. </p>
<p >Only first element in each group of equal elements is left. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacezll.html">zll</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
