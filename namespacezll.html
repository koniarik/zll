<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>zll: zll Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">zll
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacezll.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">zll Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__base.html">ll_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for linked list nodes containing <code><a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a></code>.  <a href="structzll_1_1ll__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__const__iterator.html">ll_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list const-iterator, needs just pointer to node.  <a href="structzll_1_1ll__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__header.html">ll_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked-list header containing pointers to the next and previous elements or the list itself.  <a href="structzll_1_1ll__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__iterator.html">ll_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list iterator, needs just pointer to node.  <a href="structzll_1_1ll__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__list.html">ll_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning linked list container, expects nodes to contain <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a> as member.  <a href="structzll_1_1ll__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__base.html">sh_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for skew heap nodes containing <code><a class="el" href="structzll_1_1sh__header.html" title="Skew heap header containing pointers to left and right children and to the parent node or heap.">sh_header</a></code>.  <a href="structzll_1_1sh__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__header.html">sh_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew heap header containing pointers to left and right children and to the parent node or heap.  <a href="structzll_1_1sh__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__heap.html">sh_heap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew heap implementation.  <a href="structzll_1_1sh__heap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d418476eff4046b39fc5d0335ff6693"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a6d418476eff4046b39fc5d0335ff6693"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6d418476eff4046b39fc5d0335ff6693">detach</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a6d418476eff4046b39fc5d0335ff6693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from the list.  <a href="namespacezll.html#a6d418476eff4046b39fc5d0335ff6693">More...</a><br /></td></tr>
<tr class="separator:a6d418476eff4046b39fc5d0335ff6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639d609c33a126597e38011900c08364"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:a639d609c33a126597e38011900c08364"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a639d609c33a126597e38011900c08364">detach</a> (T &amp;node, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="memdesc:a639d609c33a126597e38011900c08364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from the heap.  <a href="namespacezll.html#a639d609c33a126597e38011900c08364">More...</a><br /></td></tr>
<tr class="separator:a639d609c33a126597e38011900c08364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee72801f82d0cebea0f695436f422f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a5aee72801f82d0cebea0f695436f422f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5aee72801f82d0cebea0f695436f422f">detach_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5aee72801f82d0cebea0f695436f422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches subrange [first, last] from the list.  <a href="namespacezll.html#a5aee72801f82d0cebea0f695436f422f">More...</a><br /></td></tr>
<tr class="separator:a5aee72801f82d0cebea0f695436f422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4686b548a6c2812e4ee2e6f9ab3ab8fa">detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from list.  <a href="namespacezll.html#a4686b548a6c2812e4ee2e6f9ab3ab8fa">More...</a><br /></td></tr>
<tr class="separator:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1e5f7f94bac5fc728b19ee708f3fc2ff">detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from heap.  <a href="namespacezll.html#a1e5f7f94bac5fc728b19ee708f3fc2ff">More...</a><br /></td></tr>
<tr class="separator:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0b9647befb868890b60caf39f3d293"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:aee0b9647befb868890b60caf39f3d293"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aee0b9647befb868890b60caf39f3d293">detached_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aee0b9647befb868890b60caf39f3d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range is detached from list.  <a href="namespacezll.html#aee0b9647befb868890b60caf39f3d293">More...</a><br /></td></tr>
<tr class="separator:aee0b9647befb868890b60caf39f3d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ace8082eb072c3286742c3b17b825b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a2ace8082eb072c3286742c3b17b825b9"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a2ace8082eb072c3286742c3b17b825b9">find_if_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:a2ace8082eb072c3286742c3b17b825b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found.  <a href="namespacezll.html#a2ace8082eb072c3286742c3b17b825b9">More...</a><br /></td></tr>
<tr class="separator:a2ace8082eb072c3286742c3b17b825b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8723bf61a7e944036fb5dfce168d70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a5b8723bf61a7e944036fb5dfce168d70"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5b8723bf61a7e944036fb5dfce168d70">first_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5b8723bf61a7e944036fb5dfce168d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over predecessors of node <code>n</code> and return the first node in the list.  <a href="namespacezll.html#a5b8723bf61a7e944036fb5dfce168d70">More...</a><br /></td></tr>
<tr class="separator:a5b8723bf61a7e944036fb5dfce168d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55da35af7a7e04b1898f7562f8274b7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:ab55da35af7a7e04b1898f7562f8274b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ab55da35af7a7e04b1898f7562f8274b7">for_each_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:ab55da35af7a7e04b1898f7562f8274b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node.  <a href="namespacezll.html#ab55da35af7a7e04b1898f7562f8274b7">More...</a><br /></td></tr>
<tr class="separator:ab55da35af7a7e04b1898f7562f8274b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a18cb8f77ce9ca47bc8d873ec2bda5a7a">inorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the heap in-order and call <code>f</code> for each node.  <a href="namespacezll.html#a18cb8f77ce9ca47bc8d873ec2bda5a7a">More...</a><br /></td></tr>
<tr class="separator:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a71541bac40e1e9feef56f551b0bbe9ce">last_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a71541bac40e1e9feef56f551b0bbe9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over successors of node <code>n</code> and return the last node in the list.  <a href="namespacezll.html#a71541bac40e1e9feef56f551b0bbe9ce">More...</a><br /></td></tr>
<tr class="separator:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e37f363fceef88778368b5d5dc860"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a1d8e37f363fceef88778368b5d5dc860"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1d8e37f363fceef88778368b5d5dc860">link_detached</a> (T &amp;n1, T &amp;n2, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="memdesc:a1d8e37f363fceef88778368b5d5dc860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a detached node <code>n2</code> to the parent of <code>n1</code>.  <a href="namespacezll.html#a1d8e37f363fceef88778368b5d5dc860">More...</a><br /></td></tr>
<tr class="separator:a1d8e37f363fceef88778368b5d5dc860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c452ca25356a01e4ac1a88d341add"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:ad06c452ca25356a01e4ac1a88d341add"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ad06c452ca25356a01e4ac1a88d341add">link_detached_as_first</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ad06c452ca25356a01e4ac1a88d341add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#ad06c452ca25356a01e4ac1a88d341add">More...</a><br /></td></tr>
<tr class="separator:ad06c452ca25356a01e4ac1a88d341add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c1bab91c3855c29f296a9899f43341"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a19c1bab91c3855c29f296a9899f43341"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a19c1bab91c3855c29f296a9899f43341">link_detached_as_last</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a19c1bab91c3855c29f296a9899f43341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#a19c1bab91c3855c29f296a9899f43341">More...</a><br /></td></tr>
<tr class="separator:a19c1bab91c3855c29f296a9899f43341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528cd753e28cd0fab24c8ce781d7776c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a528cd753e28cd0fab24c8ce781d7776c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a528cd753e28cd0fab24c8ce781d7776c">link_detached_as_next</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a528cd753e28cd0fab24c8ce781d7776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>.  <a href="namespacezll.html#a528cd753e28cd0fab24c8ce781d7776c">More...</a><br /></td></tr>
<tr class="separator:a528cd753e28cd0fab24c8ce781d7776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aaec58819ce3b46a79a6ba5beef9f2fc1">link_detached_as_prev</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>.  <a href="namespacezll.html#aaec58819ce3b46a79a6ba5beef9f2fc1">More...</a><br /></td></tr>
<tr class="separator:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b79e5297c4978343fc0e99dc5088d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a856b79e5297c4978343fc0e99dc5088d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a856b79e5297c4978343fc0e99dc5088d">link_detached_to</a> (T &amp;node, T &amp;other, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="memdesc:a856b79e5297c4978343fc0e99dc5088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a detached node <code>other</code> to <code>node</code>.  <a href="namespacezll.html#a856b79e5297c4978343fc0e99dc5088d">More...</a><br /></td></tr>
<tr class="separator:a856b79e5297c4978343fc0e99dc5088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a60d848eba83fa0a8aa19aa4a6496328e">link_group</a> (std::initializer_list&lt; T * &gt; nodes)</td></tr>
<tr class="memdesc:a60d848eba83fa0a8aa19aa4a6496328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link nodes in <code>nodes</code> in order as successors of each other.  <a href="namespacezll.html#a60d848eba83fa0a8aa19aa4a6496328e">More...</a><br /></td></tr>
<tr class="separator:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#abc80f9ef1f7cebd1cfb3d12751a72366">link_range_as_next</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as successor of node <code>n</code>.  <a href="namespacezll.html#abc80f9ef1f7cebd1cfb3d12751a72366">More...</a><br /></td></tr>
<tr class="separator:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a86fc7485c5d05f2dc303cbb342d05eef">link_range_as_prev</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a86fc7485c5d05f2dc303cbb342d05eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as predecessor of node <code>n</code>.  <a href="namespacezll.html#a86fc7485c5d05f2dc303cbb342d05eef">More...</a><br /></td></tr>
<tr class="separator:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a42243d44581d8f0ee1e9c18d4acf2184">merge_ranges</a> (T &amp;lhf, T &amp;lhl, T &amp;rhf, T &amp;rhl, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(comp(lhf, rhf)))</td></tr>
<tr class="memdesc:a42243d44581d8f0ee1e9c18d4acf2184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two ranges [lhf, lhl] and [rhf, rhl] into one range.  <a href="namespacezll.html#a42243d44581d8f0ee1e9c18d4acf2184">More...</a><br /></td></tr>
<tr class="separator:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144697c395d7e039e0aca2a585fbe792"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a144697c395d7e039e0aca2a585fbe792"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a144697c395d7e039e0aca2a585fbe792">move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a144697c395d7e039e0aca2a585fbe792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node.  <a href="namespacezll.html#a144697c395d7e039e0aca2a585fbe792">More...</a><br /></td></tr>
<tr class="separator:a144697c395d7e039e0aca2a585fbe792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a24b2449a29846b12ecb477ed4a52f8f0">move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a24b2449a29846b12ecb477ed4a52f8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links all children from <code>from</code> node to <code>to</code> node. The <code>to</code> node must be detached.  <a href="namespacezll.html#a24b2449a29846b12ecb477ed4a52f8f0">More...</a><br /></td></tr>
<tr class="separator:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daf6432db70018790a23a5b9bad24a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a8daf6432db70018790a23a5b9bad24a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a8daf6432db70018790a23a5b9bad24a6">postorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a8daf6432db70018790a23a5b9bad24a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the heap post-order and call <code>f</code> for each node.  <a href="namespacezll.html#a8daf6432db70018790a23a5b9bad24a6">More...</a><br /></td></tr>
<tr class="separator:a8daf6432db70018790a23a5b9bad24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73348745e5791eb7557fd8367a7e14ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a73348745e5791eb7557fd8367a7e14ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a73348745e5791eb7557fd8367a7e14ff">preorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a73348745e5791eb7557fd8367a7e14ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the heap pre-order and call <code>f</code> for each node.  <a href="namespacezll.html#a73348745e5791eb7557fd8367a7e14ff">More...</a><br /></td></tr>
<tr class="separator:a73348745e5791eb7557fd8367a7e14ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccc5e1d745179f3326f0ff913454176"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a1ccc5e1d745179f3326f0ff913454176"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1ccc5e1d745179f3326f0ff913454176">range_qsort</a> (T &amp;first, T &amp;last, Compare &amp;&amp;cmp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(cmp(first, last)))</td></tr>
<tr class="memdesc:a1ccc5e1d745179f3326f0ff913454176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes.  <a href="namespacezll.html#a1ccc5e1d745179f3326f0ff913454176">More...</a><br /></td></tr>
<tr class="separator:a1ccc5e1d745179f3326f0ff913454176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Pred &gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4bd2dd1625cac198e1fc0e293555e9f0">range_remove</a> (T &amp;first, T &amp;last, Pred &amp;&amp;p) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first)))</td></tr>
<tr class="memdesc:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a4bd2dd1625cac198e1fc0e293555e9f0">More...</a><br /></td></tr>
<tr class="separator:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34016023d1d718ae8bfb47426a3a7c39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a34016023d1d718ae8bfb47426a3a7c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a34016023d1d718ae8bfb47426a3a7c39">range_reverse</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a34016023d1d718ae8bfb47426a3a7c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse order of nodes in the range [first, last].  <a href="namespacezll.html#a34016023d1d718ae8bfb47426a3a7c39">More...</a><br /></td></tr>
<tr class="separator:a34016023d1d718ae8bfb47426a3a7c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a0f5d6a98fc40a5b09ff7b6db2f55dff5">range_unique</a> (T &amp;first, T &amp;last, BinPred &amp;&amp;p=std::equal_to&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first, last)))</td></tr>
<tr class="memdesc:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a0f5d6a98fc40a5b09ff7b6db2f55dff5">More...</a><br /></td></tr>
<tr class="separator:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a71983897a243ee29a1a0d1ce5f1ad236">top_node_of</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a71983897a243ee29a1a0d1ce5f1ad236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top node of the heap that <code>node</code> is in.  <a href="namespacezll.html#a71983897a243ee29a1a0d1ce5f1ad236">More...</a><br /></td></tr>
<tr class="separator:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6d418476eff4046b39fc5d0335ff6693" name="a6d418476eff4046b39fc5d0335ff6693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d418476eff4046b39fc5d0335ff6693">&#9670;&#160;</a></span>detach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlink a node from the list. </p>
<p >Previous or following node are linked together instead. Node itself does not keep any connections. </p>

</div>
</div>
<a id="a639d609c33a126597e38011900c08364" name="a639d609c33a126597e38011900c08364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639d609c33a126597e38011900c08364">&#9670;&#160;</a></span>detach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlink a node from the heap. </p>
<p >If the node has two children, they are merged using <code>comp</code> and the result is linked to the parent of the detached node. If the node has one child, that child is linked to the parent of the detached node. If the node has no children, the parent pointer is set to nullptr. </p>

</div>
</div>
<a id="a5aee72801f82d0cebea0f695436f422f" name="a5aee72801f82d0cebea0f695436f422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aee72801f82d0cebea0f695436f422f">&#9670;&#160;</a></span>detach_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach_range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches subrange [first, last] from the list. </p>
<p >The range is not linked to any other node after detachment. Successor of <code>last</code> and predecessor of <code>first</code> are linked together. </p>

</div>
</div>
<a id="a4686b548a6c2812e4ee2e6f9ab3ab8fa" name="a4686b548a6c2812e4ee2e6f9ab3ab8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4686b548a6c2812e4ee2e6f9ab3ab8fa">&#9670;&#160;</a></span>detached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is detached from list. </p>

</div>
</div>
<a id="a1e5f7f94bac5fc728b19ee708f3fc2ff" name="a1e5f7f94bac5fc728b19ee708f3fc2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5f7f94bac5fc728b19ee708f3fc2ff">&#9670;&#160;</a></span>detached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is detached from heap. </p>

</div>
</div>
<a id="aee0b9647befb868890b60caf39f3d293" name="aee0b9647befb868890b60caf39f3d293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0b9647befb868890b60caf39f3d293">&#9670;&#160;</a></span>detached_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached_range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the range is detached from list. </p>

</div>
</div>
<a id="a2ace8082eb072c3286742c3b17b825b9" name="a2ace8082eb072c3286742c3b17b825b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ace8082eb072c3286742c3b17b825b9">&#9670;&#160;</a></span>find_if_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * zll::find_if_node </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found. </p>
<p >Return pointer to such node, nullptr otherwise.</p>
<p >The order of the nodes is: predecessors, <code>n</code>, successors. </p>

</div>
</div>
<a id="a5b8723bf61a7e944036fb5dfce168d70" name="a5b8723bf61a7e944036fb5dfce168d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8723bf61a7e944036fb5dfce168d70">&#9670;&#160;</a></span>first_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::first_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over predecessors of node <code>n</code> and return the first node in the list. </p>

</div>
</div>
<a id="ab55da35af7a7e04b1898f7562f8274b7" name="ab55da35af7a7e04b1898f7562f8274b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55da35af7a7e04b1898f7562f8274b7">&#9670;&#160;</a></span>for_each_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::for_each_node </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node. </p>
<p >The order of the nodes is: predecessors, <code>n</code>, successors. </p>

</div>
</div>
<a id="a18cb8f77ce9ca47bc8d873ec2bda5a7a" name="a18cb8f77ce9ca47bc8d873ec2bda5a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cb8f77ce9ca47bc8d873ec2bda5a7a">&#9670;&#160;</a></span>inorder_traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::inorder_traverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the heap in-order and call <code>f</code> for each node. </p>
<p >The order of the nodes is: left child, node, right child. </p>

</div>
</div>
<a id="a71541bac40e1e9feef56f551b0bbe9ce" name="a71541bac40e1e9feef56f551b0bbe9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71541bac40e1e9feef56f551b0bbe9ce">&#9670;&#160;</a></span>last_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::last_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over successors of node <code>n</code> and return the last node in the list. </p>

</div>
</div>
<a id="a1d8e37f363fceef88778368b5d5dc860" name="a1d8e37f363fceef88778368b5d5dc860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8e37f363fceef88778368b5d5dc860">&#9670;&#160;</a></span>link_detached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link a detached node <code>n2</code> to the parent of <code>n1</code>. </p>
<p >Maintains the heap property using <code>comp</code>. The <code>n2</code> node must be detached before calling this function. </p>

</div>
</div>
<a id="ad06c452ca25356a01e4ac1a88d341add" name="ad06c452ca25356a01e4ac1a88d341add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c452ca25356a01e4ac1a88d341add">&#9670;&#160;</a></span>link_detached_as_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_first </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a19c1bab91c3855c29f296a9899f43341" name="a19c1bab91c3855c29f296a9899f43341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c1bab91c3855c29f296a9899f43341">&#9670;&#160;</a></span>link_detached_as_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_last </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a528cd753e28cd0fab24c8ce781d7776c" name="a528cd753e28cd0fab24c8ce781d7776c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528cd753e28cd0fab24c8ce781d7776c">&#9670;&#160;</a></span>link_detached_as_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_next </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="aaec58819ce3b46a79a6ba5beef9f2fc1" name="aaec58819ce3b46a79a6ba5beef9f2fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec58819ce3b46a79a6ba5beef9f2fc1">&#9670;&#160;</a></span>link_detached_as_prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_prev </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a856b79e5297c4978343fc0e99dc5088d" name="a856b79e5297c4978343fc0e99dc5088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856b79e5297c4978343fc0e99dc5088d">&#9670;&#160;</a></span>link_detached_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link a detached node <code>other</code> to <code>node</code>. </p>
<p >Maintains the heap property using <code>comp</code>. The <code>other</code> node must be detached before calling this function. </p>

</div>
</div>
<a id="a60d848eba83fa0a8aa19aa4a6496328e" name="a60d848eba83fa0a8aa19aa4a6496328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d848eba83fa0a8aa19aa4a6496328e">&#9670;&#160;</a></span>link_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_group </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T * &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link nodes in <code>nodes</code> in order as successors of each other. </p>
<p >Undefined behavior if any of the nodes is not detached. </p>

</div>
</div>
<a id="abc80f9ef1f7cebd1cfb3d12751a72366" name="abc80f9ef1f7cebd1cfb3d12751a72366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc80f9ef1f7cebd1cfb3d12751a72366">&#9670;&#160;</a></span>link_range_as_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_range_as_next </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached range [first, last] as successor of node <code>n</code>. </p>
<p >Undefined behavior if sublist [first, last] is not detached. The range is linked as successor of <code>n</code> and the last element of the range is linked as predecessor of previous <code>n</code> successor. </p>

</div>
</div>
<a id="a86fc7485c5d05f2dc303cbb342d05eef" name="a86fc7485c5d05f2dc303cbb342d05eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fc7485c5d05f2dc303cbb342d05eef">&#9670;&#160;</a></span>link_range_as_prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_range_as_prev </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached range [first, last] as predecessor of node <code>n</code>. </p>
<p >Undefined behavior if sublist [first, last] is not detached. The range is linked as predecessor of <code>n</code> and the first element of the range is linked as successor of previous <code>n</code> predecessor. </p>

</div>
</div>
<a id="a42243d44581d8f0ee1e9c18d4acf2184" name="a42243d44581d8f0ee1e9c18d4acf2184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42243d44581d8f0ee1e9c18d4acf2184">&#9670;&#160;</a></span>merge_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T *, T * &gt; zll::merge_ranges </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge two ranges [lhf, lhl] and [rhf, rhl] into one range. </p>
<p >Uses <code>comp</code> to determine the order of the elements in the resulting range. Pointers to the first and last elements of the resulting range are returned. </p>

</div>
</div>
<a id="a144697c395d7e039e0aca2a585fbe792" name="a144697c395d7e039e0aca2a585fbe792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144697c395d7e039e0aca2a585fbe792">&#9670;&#160;</a></span>move_from_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::move_from_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node. </p>
<p >The <code>to</code> node must be detached. </p>

</div>
</div>
<a id="a24b2449a29846b12ecb477ed4a52f8f0" name="a24b2449a29846b12ecb477ed4a52f8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b2449a29846b12ecb477ed4a52f8f0">&#9670;&#160;</a></span>move_from_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::move_from_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links all children from <code>from</code> node to <code>to</code> node. The <code>to</code> node must be detached. </p>

</div>
</div>
<a id="a8daf6432db70018790a23a5b9bad24a6" name="a8daf6432db70018790a23a5b9bad24a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daf6432db70018790a23a5b9bad24a6">&#9670;&#160;</a></span>postorder_traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::postorder_traverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the heap post-order and call <code>f</code> for each node. </p>
<p >The order of the nodes is: left child, right child, node. </p>

</div>
</div>
<a id="a73348745e5791eb7557fd8367a7e14ff" name="a73348745e5791eb7557fd8367a7e14ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73348745e5791eb7557fd8367a7e14ff">&#9670;&#160;</a></span>preorder_traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::preorder_traverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the heap pre-order and call <code>f</code> for each node. </p>
<p >The order of the nodes is: node, left child, right child. </p>

</div>
</div>
<a id="a1ccc5e1d745179f3326f0ff913454176" name="a1ccc5e1d745179f3326f0ff913454176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccc5e1d745179f3326f0ff913454176">&#9670;&#160;</a></span>range_qsort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::range_qsort </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes. </p>

</div>
</div>
<a id="a4bd2dd1625cac198e1fc0e293555e9f0" name="a4bd2dd1625cac198e1fc0e293555e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd2dd1625cac198e1fc0e293555e9f0">&#9670;&#160;</a></span>range_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Pred &gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t zll::range_remove </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes in the range [first, last] for which <code>p</code> returns true. </p>
<p >Returns the number of removed nodes. </p>

</div>
</div>
<a id="a34016023d1d718ae8bfb47426a3a7c39" name="a34016023d1d718ae8bfb47426a3a7c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34016023d1d718ae8bfb47426a3a7c39">&#9670;&#160;</a></span>range_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::range_reverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse order of nodes in the range [first, last]. </p>
<p >The first node in the range will become the last node and the last node will become the first node. </p>

</div>
</div>
<a id="a0f5d6a98fc40a5b09ff7b6db2f55dff5" name="a0f5d6a98fc40a5b09ff7b6db2f55dff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5d6a98fc40a5b09ff7b6db2f55dff5">&#9670;&#160;</a></span>range_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t zll::range_unique </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinPred &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em> = <code>std::equal_to&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true. </p>
<p >Only first element in each group of equal elements is left. </p>

</div>
</div>
<a id="a71983897a243ee29a1a0d1ce5f1ad236" name="a71983897a243ee29a1a0d1ce5f1ad236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71983897a243ee29a1a0d1ce5f1ad236">&#9670;&#160;</a></span>top_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::top_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top node of the heap that <code>node</code> is in. </p>
<p >The top node is the node that has no parent and is an ancestor of <code>node</code>. If <code>node</code> is detached, it is returned. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacezll.html">zll</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
