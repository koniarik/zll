<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>zll: zll Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">zll
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacezll.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">zll Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1__vptr.html">_vptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__base.html">ll_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for linked list nodes containing <code><a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a></code>.  <a href="structzll_1_1ll__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__const__iterator.html">ll_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list const-iterator, needs just pointer to node.  <a href="structzll_1_1ll__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__header.html">ll_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked-list header containing pointers to the next and previous elements or the list itself.  <a href="structzll_1_1ll__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__iterator.html">ll_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard linked list iterator, needs just pointer to node.  <a href="structzll_1_1ll__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1ll__list.html">ll_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning linked list container, expects nodes to contain <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a> as member.  <a href="structzll_1_1ll__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__base.html">sh_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__header.html">sh_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzll_1_1sh__heap.html">sh_heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__nothrow__access.html">_nothrow_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__nothrow__access__compare.html">_nothrow_access_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__provides__ll__header.html">_provides_ll_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptzll_1_1__provides__sh__header.html">_provides_sh_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1d61dbaf61de26105350353407fec4dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a1d61dbaf61de26105350353407fec4dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a> = <a class="el" href="structzll_1_1__vptr.html">_vptr</a>&lt; T, <a class="el" href="structzll_1_1ll__list.html">ll_list</a>&lt; T, Acc &gt; &gt;</td></tr>
<tr class="memdesc:a1d61dbaf61de26105350353407fec4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic ptr wrapper pointer either to <a class="el" href="structzll_1_1ll__list.html" title="Non-owning linked list container, expects nodes to contain ll_header as member.">ll_list</a> or node with <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a>.  <a href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">More...</a><br /></td></tr>
<tr class="separator:a1d61dbaf61de26105350353407fec4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4103d2220bdc7be9c33845fca16a88"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a9a4103d2220bdc7be9c33845fca16a88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">_sh_ptr</a> = <a class="el" href="structzll_1_1__vptr.html">_vptr</a>&lt; T, <a class="el" href="structzll_1_1sh__heap.html">sh_heap</a>&lt; T, Acc, Compare &gt; &gt;</td></tr>
<tr class="separator:a9a4103d2220bdc7be9c33845fca16a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5ef02179fbe75cb5d79304b47220f96d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a5ef02179fbe75cb5d79304b47220f96d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5ef02179fbe75cb5d79304b47220f96d">_attach_left</a> (T &amp;parent, T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a5ef02179fbe75cb5d79304b47220f96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf804f85df1acb7b8da0bcabd0b7e8ed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </td></tr>
<tr class="memitem:adf804f85df1acb7b8da0bcabd0b7e8ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#adf804f85df1acb7b8da0bcabd0b7e8ed">_attach_parent</a> (T &amp;node, <a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">_sh_ptr</a>&lt; T, Acc, Compare &gt; p) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:adf804f85df1acb7b8da0bcabd0b7e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cd33deb6dedef29f3e39af230ad4b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a36cd33deb6dedef29f3e39af230ad4b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a36cd33deb6dedef29f3e39af230ad4b5">_attach_right</a> (T &amp;parent, T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a36cd33deb6dedef29f3e39af230ad4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c1c4d9b83f05ff596a3a211977e99"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </td></tr>
<tr class="memitem:a763c1c4d9b83f05ff596a3a211977e99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a763c1c4d9b83f05ff596a3a211977e99">_attach_top</a> (<a class="el" href="structzll_1_1sh__heap.html">sh_heap</a>&lt; T, Acc, Compare &gt; &amp;parent, T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a763c1c4d9b83f05ff596a3a211977e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b01c9d516b5bf6cbe015ac4b93fbc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a295b01c9d516b5bf6cbe015ac4b93fbc"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a295b01c9d516b5bf6cbe015ac4b93fbc">_detach_left</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a295b01c9d516b5bf6cbe015ac4b93fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b88d1bc80ea55901a2442ae7db32b18"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a3b88d1bc80ea55901a2442ae7db32b18"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a3b88d1bc80ea55901a2442ae7db32b18">_detach_parent</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a3b88d1bc80ea55901a2442ae7db32b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af648efdec4d274460dcca5defc183e1d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:af648efdec4d274460dcca5defc183e1d"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#af648efdec4d274460dcca5defc183e1d">_detach_right</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:af648efdec4d274460dcca5defc183e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd36ad389c46eac793f18c5a00aa983"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </td></tr>
<tr class="memitem:a6cd36ad389c46eac793f18c5a00aa983"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6cd36ad389c46eac793f18c5a00aa983">_detach_top</a> (<a class="el" href="structzll_1_1sh__heap.html">sh_heap</a>&lt; T, Acc, Compare &gt; &amp;parent) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a6cd36ad389c46eac793f18c5a00aa983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9eadfd87de5aa168bc390008668685"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a7c9eadfd87de5aa168bc390008668685"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a7c9eadfd87de5aa168bc390008668685">_heap</a> (<a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">_sh_ptr</a>&lt; T, Acc, Compare &gt; p) noexcept</td></tr>
<tr class="separator:a7c9eadfd87de5aa168bc390008668685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ee2786d9ecf29fa220db757b470f46"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a64ee2786d9ecf29fa220db757b470f46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a64ee2786d9ecf29fa220db757b470f46">_list</a> (<a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt; p) noexcept</td></tr>
<tr class="separator:a64ee2786d9ecf29fa220db757b470f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee5bb8c9ab624afd393f64acf5a628"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:abaee5bb8c9ab624afd393f64acf5a628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#abaee5bb8c9ab624afd393f64acf5a628">_next_or_first_set</a> (<a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt; p, <a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt; n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:abaee5bb8c9ab624afd393f64acf5a628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f3d9775a158c210e833a1b0cd11527"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:ab8f3d9775a158c210e833a1b0cd11527"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ab8f3d9775a158c210e833a1b0cd11527">_node</a> (<a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt; p) noexcept</td></tr>
<tr class="separator:ab8f3d9775a158c210e833a1b0cd11527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3d8080d9ae62d8bc470d715f7717fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a5e3d8080d9ae62d8bc470d715f7717fd"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5e3d8080d9ae62d8bc470d715f7717fd">_node</a> (<a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">_sh_ptr</a>&lt; T, Acc, Compare &gt; p) noexcept</td></tr>
<tr class="separator:a5e3d8080d9ae62d8bc470d715f7717fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d110bc2c6e4d316a398db52593d21c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:a33d110bc2c6e4d316a398db52593d21c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a33d110bc2c6e4d316a398db52593d21c">_prev_or_last_set</a> (<a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt; p, <a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt; n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a33d110bc2c6e4d316a398db52593d21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf971addd6e7635bba4603aa5fd7d38"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; </td></tr>
<tr class="memitem:aadf971addd6e7635bba4603aa5fd7d38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aadf971addd6e7635bba4603aa5fd7d38">_replace_in_parent</a> (T &amp;node, T &amp;new_node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:aadf971addd6e7635bba4603aa5fd7d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e4c778914020642ccfc3ddd833a260"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare &gt; </td></tr>
<tr class="memitem:a91e4c778914020642ccfc3ddd833a260"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a91e4c778914020642ccfc3ddd833a260">_sh_merge</a> (T &amp;left, T &amp;right, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a91e4c778914020642ccfc3ddd833a260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f11d2c10e737aac00294f05f0f352d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare &gt; </td></tr>
<tr class="memitem:a96f11d2c10e737aac00294f05f0f352d"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a96f11d2c10e737aac00294f05f0f352d">_sh_merge_impl</a> (T &amp;left, T &amp;right, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a96f11d2c10e737aac00294f05f0f352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cd4fcb105442fbcbb359050182f988"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:aa9cd4fcb105442fbcbb359050182f988"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aa9cd4fcb105442fbcbb359050182f988">_sh_pop</a> (T &amp;node, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:aa9cd4fcb105442fbcbb359050182f988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d418476eff4046b39fc5d0335ff6693"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a6d418476eff4046b39fc5d0335ff6693"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a6d418476eff4046b39fc5d0335ff6693">detach</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a6d418476eff4046b39fc5d0335ff6693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a node from existing list.  <a href="namespacezll.html#a6d418476eff4046b39fc5d0335ff6693">More...</a><br /></td></tr>
<tr class="separator:a6d418476eff4046b39fc5d0335ff6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639d609c33a126597e38011900c08364"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:a639d609c33a126597e38011900c08364"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a639d609c33a126597e38011900c08364">detach</a> (T &amp;node, Compare &amp;&amp;comp) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a639d609c33a126597e38011900c08364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee72801f82d0cebea0f695436f422f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a5aee72801f82d0cebea0f695436f422f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5aee72801f82d0cebea0f695436f422f">detach_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5aee72801f82d0cebea0f695436f422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches subrange [first, last] from the list.  <a href="namespacezll.html#a5aee72801f82d0cebea0f695436f422f">More...</a><br /></td></tr>
<tr class="separator:a5aee72801f82d0cebea0f695436f422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4686b548a6c2812e4ee2e6f9ab3ab8fa">detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from list.  <a href="namespacezll.html#a4686b548a6c2812e4ee2e6f9ab3ab8fa">More...</a><br /></td></tr>
<tr class="separator:a4686b548a6c2812e4ee2e6f9ab3ab8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</td></tr>
<tr class="memitem:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1e5f7f94bac5fc728b19ee708f3fc2ff">detached</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is detached from heap.  <a href="namespacezll.html#a1e5f7f94bac5fc728b19ee708f3fc2ff">More...</a><br /></td></tr>
<tr class="separator:a1e5f7f94bac5fc728b19ee708f3fc2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0b9647befb868890b60caf39f3d293"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:aee0b9647befb868890b60caf39f3d293"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aee0b9647befb868890b60caf39f3d293">detached_range</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aee0b9647befb868890b60caf39f3d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range is detached from list.  <a href="namespacezll.html#aee0b9647befb868890b60caf39f3d293">More...</a><br /></td></tr>
<tr class="separator:aee0b9647befb868890b60caf39f3d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ace8082eb072c3286742c3b17b825b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a2ace8082eb072c3286742c3b17b825b9"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a2ace8082eb072c3286742c3b17b825b9">find_if_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:a2ace8082eb072c3286742c3b17b825b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found.  <a href="namespacezll.html#a2ace8082eb072c3286742c3b17b825b9">More...</a><br /></td></tr>
<tr class="separator:a2ace8082eb072c3286742c3b17b825b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8723bf61a7e944036fb5dfce168d70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a5b8723bf61a7e944036fb5dfce168d70"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a5b8723bf61a7e944036fb5dfce168d70">first_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a5b8723bf61a7e944036fb5dfce168d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over predecessors of node <code>n</code> and return the first node in the list.  <a href="namespacezll.html#a5b8723bf61a7e944036fb5dfce168d70">More...</a><br /></td></tr>
<tr class="separator:a5b8723bf61a7e944036fb5dfce168d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55da35af7a7e04b1898f7562f8274b7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:ab55da35af7a7e04b1898f7562f8274b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ab55da35af7a7e04b1898f7562f8274b7">for_each_node</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(f(n)))</td></tr>
<tr class="memdesc:ab55da35af7a7e04b1898f7562f8274b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node.  <a href="namespacezll.html#ab55da35af7a7e04b1898f7562f8274b7">More...</a><br /></td></tr>
<tr class="separator:ab55da35af7a7e04b1898f7562f8274b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a18cb8f77ce9ca47bc8d873ec2bda5a7a">inorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a18cb8f77ce9ca47bc8d873ec2bda5a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a71541bac40e1e9feef56f551b0bbe9ce">last_node_of</a> (T &amp;n) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a71541bac40e1e9feef56f551b0bbe9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over successors of node <code>n</code> and return the last node in the list.  <a href="namespacezll.html#a71541bac40e1e9feef56f551b0bbe9ce">More...</a><br /></td></tr>
<tr class="separator:a71541bac40e1e9feef56f551b0bbe9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e37f363fceef88778368b5d5dc860"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a1d8e37f363fceef88778368b5d5dc860"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1d8e37f363fceef88778368b5d5dc860">link_detached</a> (T &amp;n1, T &amp;n2, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a1d8e37f363fceef88778368b5d5dc860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c452ca25356a01e4ac1a88d341add"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:ad06c452ca25356a01e4ac1a88d341add"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#ad06c452ca25356a01e4ac1a88d341add">link_detached_as_first</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:ad06c452ca25356a01e4ac1a88d341add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#ad06c452ca25356a01e4ac1a88d341add">More...</a><br /></td></tr>
<tr class="separator:ad06c452ca25356a01e4ac1a88d341add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c1bab91c3855c29f296a9899f43341"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a19c1bab91c3855c29f296a9899f43341"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a19c1bab91c3855c29f296a9899f43341">link_detached_as_last</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a19c1bab91c3855c29f296a9899f43341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>.  <a href="namespacezll.html#a19c1bab91c3855c29f296a9899f43341">More...</a><br /></td></tr>
<tr class="separator:a19c1bab91c3855c29f296a9899f43341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528cd753e28cd0fab24c8ce781d7776c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a528cd753e28cd0fab24c8ce781d7776c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a528cd753e28cd0fab24c8ce781d7776c">link_detached_as_next</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a528cd753e28cd0fab24c8ce781d7776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>.  <a href="namespacezll.html#a528cd753e28cd0fab24c8ce781d7776c">More...</a><br /></td></tr>
<tr class="separator:a528cd753e28cd0fab24c8ce781d7776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#aaec58819ce3b46a79a6ba5beef9f2fc1">link_detached_as_prev</a> (T &amp;n, T &amp;d) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>.  <a href="namespacezll.html#aaec58819ce3b46a79a6ba5beef9f2fc1">More...</a><br /></td></tr>
<tr class="separator:aaec58819ce3b46a79a6ba5beef9f2fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3735f9abc58f2c4a5775a9ee0008df7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a3735f9abc58f2c4a5775a9ee0008df7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a3735f9abc58f2c4a5775a9ee0008df7e">link_detached_copy_of</a> (T &amp;node, T &amp;cpy, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access_compare&lt; Acc, T, Compare &gt;)</td></tr>
<tr class="separator:a3735f9abc58f2c4a5775a9ee0008df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a60d848eba83fa0a8aa19aa4a6496328e">link_group</a> (std::initializer_list&lt; T * &gt; nodes)</td></tr>
<tr class="memdesc:a60d848eba83fa0a8aa19aa4a6496328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link nodes in <code>nodes</code> in order as successors of each other.  <a href="namespacezll.html#a60d848eba83fa0a8aa19aa4a6496328e">More...</a><br /></td></tr>
<tr class="separator:a60d848eba83fa0a8aa19aa4a6496328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#abc80f9ef1f7cebd1cfb3d12751a72366">link_range_as_next</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as successor of node <code>n</code>.  <a href="namespacezll.html#abc80f9ef1f7cebd1cfb3d12751a72366">More...</a><br /></td></tr>
<tr class="separator:abc80f9ef1f7cebd1cfb3d12751a72366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a86fc7485c5d05f2dc303cbb342d05eef">link_range_as_prev</a> (T &amp;n, T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a86fc7485c5d05f2dc303cbb342d05eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link detached range [first, last] as predecessor of node <code>n</code>.  <a href="namespacezll.html#a86fc7485c5d05f2dc303cbb342d05eef">More...</a><br /></td></tr>
<tr class="separator:a86fc7485c5d05f2dc303cbb342d05eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a42243d44581d8f0ee1e9c18d4acf2184">merge_ranges</a> (T &amp;lhf, T &amp;lhl, T &amp;rhf, T &amp;rhl, Compare &amp;&amp;comp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(comp(lhf, rhf)))</td></tr>
<tr class="memdesc:a42243d44581d8f0ee1e9c18d4acf2184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two ranges [lhf, lhl] and [rhf, rhl] into one range.  <a href="namespacezll.html#a42243d44581d8f0ee1e9c18d4acf2184">More...</a><br /></td></tr>
<tr class="separator:a42243d44581d8f0ee1e9c18d4acf2184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144697c395d7e039e0aca2a585fbe792"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a144697c395d7e039e0aca2a585fbe792"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a144697c395d7e039e0aca2a585fbe792">move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a144697c395d7e039e0aca2a585fbe792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node.  <a href="namespacezll.html#a144697c395d7e039e0aca2a585fbe792">More...</a><br /></td></tr>
<tr class="separator:a144697c395d7e039e0aca2a585fbe792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a24b2449a29846b12ecb477ed4a52f8f0">move_from_to</a> (T &amp;from, T &amp;to) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a24b2449a29846b12ecb477ed4a52f8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daf6432db70018790a23a5b9bad24a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a8daf6432db70018790a23a5b9bad24a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a8daf6432db70018790a23a5b9bad24a6">postorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a8daf6432db70018790a23a5b9bad24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73348745e5791eb7557fd8367a7e14ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a73348745e5791eb7557fd8367a7e14ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a73348745e5791eb7557fd8367a7e14ff">preorder_traverse</a> (T &amp;n, std::invocable&lt; T &amp; &gt; auto &amp;&amp;f) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a73348745e5791eb7557fd8367a7e14ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccc5e1d745179f3326f0ff913454176"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a1ccc5e1d745179f3326f0ff913454176"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a1ccc5e1d745179f3326f0ff913454176">range_qsort</a> (T &amp;first, T &amp;last, Compare &amp;&amp;cmp=std::less&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(cmp(first, last)))</td></tr>
<tr class="memdesc:a1ccc5e1d745179f3326f0ff913454176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes.  <a href="namespacezll.html#a1ccc5e1d745179f3326f0ff913454176">More...</a><br /></td></tr>
<tr class="separator:a1ccc5e1d745179f3326f0ff913454176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename Pred &gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a4bd2dd1625cac198e1fc0e293555e9f0">range_remove</a> (T &amp;first, T &amp;last, Pred &amp;&amp;p) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first)))</td></tr>
<tr class="memdesc:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a4bd2dd1625cac198e1fc0e293555e9f0">More...</a><br /></td></tr>
<tr class="separator:a4bd2dd1625cac198e1fc0e293555e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34016023d1d718ae8bfb47426a3a7c39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a34016023d1d718ae8bfb47426a3a7c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a34016023d1d718ae8bfb47426a3a7c39">range_reverse</a> (T &amp;first, T &amp;last) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="memdesc:a34016023d1d718ae8bfb47426a3a7c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse order of nodes in the range [first, last].  <a href="namespacezll.html#a34016023d1d718ae8bfb47426a3a7c39">More...</a><br /></td></tr>
<tr class="separator:a34016023d1d718ae8bfb47426a3a7c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a0f5d6a98fc40a5b09ff7b6db2f55dff5">range_unique</a> (T &amp;first, T &amp;last, BinPred &amp;&amp;p=std::equal_to&lt;&gt;{}) noexcept(_nothrow_access&lt; Acc, T &gt; &amp;&amp;noexcept(p(first, last)))</td></tr>
<tr class="memdesc:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true.  <a href="namespacezll.html#a0f5d6a98fc40a5b09ff7b6db2f55dff5">More...</a><br /></td></tr>
<tr class="separator:a0f5d6a98fc40a5b09ff7b6db2f55dff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</td></tr>
<tr class="memitem:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezll.html#a71983897a243ee29a1a0d1ce5f1ad236">top_node_of</a> (T &amp;node) noexcept(_nothrow_access&lt; Acc, T &gt;)</td></tr>
<tr class="separator:a71983897a243ee29a1a0d1ce5f1ad236"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1d61dbaf61de26105350353407fec4dc" name="a1d61dbaf61de26105350353407fec4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d61dbaf61de26105350353407fec4dc">&#9670;&#160;</a></span>_ll_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">zll::_ll_ptr</a> = typedef <a class="el" href="structzll_1_1__vptr.html">_vptr</a>&lt; T, <a class="el" href="structzll_1_1ll__list.html">ll_list</a>&lt; T, Acc &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic ptr wrapper pointer either to <a class="el" href="structzll_1_1ll__list.html" title="Non-owning linked list container, expects nodes to contain ll_header as member.">ll_list</a> or node with <a class="el" href="structzll_1_1ll__header.html" title="Linked-list header containing pointers to the next and previous elements or the list itself.">ll_header</a>. </p>

</div>
</div>
<a id="a9a4103d2220bdc7be9c33845fca16a88" name="a9a4103d2220bdc7be9c33845fca16a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4103d2220bdc7be9c33845fca16a88">&#9670;&#160;</a></span>_sh_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">zll::_sh_ptr</a> = typedef <a class="el" href="structzll_1_1__vptr.html">_vptr</a>&lt; T, <a class="el" href="structzll_1_1sh__heap.html">sh_heap</a>&lt; T, Acc, Compare &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5ef02179fbe75cb5d79304b47220f96d" name="a5ef02179fbe75cb5d79304b47220f96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef02179fbe75cb5d79304b47220f96d">&#9670;&#160;</a></span>_attach_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::_attach_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf804f85df1acb7b8da0bcabd0b7e8ed" name="adf804f85df1acb7b8da0bcabd0b7e8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf804f85df1acb7b8da0bcabd0b7e8ed">&#9670;&#160;</a></span>_attach_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::_attach_parent </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">_sh_ptr</a>&lt; T, Acc, Compare &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36cd33deb6dedef29f3e39af230ad4b5" name="a36cd33deb6dedef29f3e39af230ad4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cd33deb6dedef29f3e39af230ad4b5">&#9670;&#160;</a></span>_attach_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::_attach_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a763c1c4d9b83f05ff596a3a211977e99" name="a763c1c4d9b83f05ff596a3a211977e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c1c4d9b83f05ff596a3a211977e99">&#9670;&#160;</a></span>_attach_top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::_attach_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzll_1_1sh__heap.html">sh_heap</a>&lt; T, Acc, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a295b01c9d516b5bf6cbe015ac4b93fbc" name="a295b01c9d516b5bf6cbe015ac4b93fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295b01c9d516b5bf6cbe015ac4b93fbc">&#9670;&#160;</a></span>_detach_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::_detach_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b88d1bc80ea55901a2442ae7db32b18" name="a3b88d1bc80ea55901a2442ae7db32b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b88d1bc80ea55901a2442ae7db32b18">&#9670;&#160;</a></span>_detach_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto zll::_detach_parent </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af648efdec4d274460dcca5defc183e1d" name="af648efdec4d274460dcca5defc183e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af648efdec4d274460dcca5defc183e1d">&#9670;&#160;</a></span>_detach_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::_detach_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cd36ad389c46eac793f18c5a00aa983" name="a6cd36ad389c46eac793f18c5a00aa983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd36ad389c46eac793f18c5a00aa983">&#9670;&#160;</a></span>_detach_top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::_detach_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzll_1_1sh__heap.html">sh_heap</a>&lt; T, Acc, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c9eadfd87de5aa168bc390008668685" name="a7c9eadfd87de5aa168bc390008668685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9eadfd87de5aa168bc390008668685">&#9670;&#160;</a></span>_heap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto * zll::_heap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">_sh_ptr</a>&lt; T, Acc, Compare &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64ee2786d9ecf29fa220db757b470f46" name="a64ee2786d9ecf29fa220db757b470f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ee2786d9ecf29fa220db757b470f46">&#9670;&#160;</a></span>_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto * zll::_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abaee5bb8c9ab624afd393f64acf5a628" name="abaee5bb8c9ab624afd393f64acf5a628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaee5bb8c9ab624afd393f64acf5a628">&#9670;&#160;</a></span>_next_or_first_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::_next_or_first_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8f3d9775a158c210e833a1b0cd11527" name="ab8f3d9775a158c210e833a1b0cd11527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f3d9775a158c210e833a1b0cd11527">&#9670;&#160;</a></span>_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto * zll::_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e3d8080d9ae62d8bc470d715f7717fd" name="a5e3d8080d9ae62d8bc470d715f7717fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3d8080d9ae62d8bc470d715f7717fd">&#9670;&#160;</a></span>_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto * zll::_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a9a4103d2220bdc7be9c33845fca16a88">_sh_ptr</a>&lt; T, Acc, Compare &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33d110bc2c6e4d316a398db52593d21c" name="a33d110bc2c6e4d316a398db52593d21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d110bc2c6e4d316a398db52593d21c">&#9670;&#160;</a></span>_prev_or_last_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::_prev_or_last_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacezll.html#a1d61dbaf61de26105350353407fec4dc">_ll_ptr</a>&lt; T, Acc &gt;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadf971addd6e7635bba4603aa5fd7d38" name="aadf971addd6e7635bba4603aa5fd7d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf971addd6e7635bba4603aa5fd7d38">&#9670;&#160;</a></span>_replace_in_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::_replace_in_parent </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91e4c778914020642ccfc3ddd833a260" name="a91e4c778914020642ccfc3ddd833a260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e4c778914020642ccfc3ddd833a260">&#9670;&#160;</a></span>_sh_merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::_sh_merge </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96f11d2c10e737aac00294f05f0f352d" name="a96f11d2c10e737aac00294f05f0f352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f11d2c10e737aac00294f05f0f352d">&#9670;&#160;</a></span>_sh_merge_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::_sh_merge_impl </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9cd4fcb105442fbcbb359050182f988" name="aa9cd4fcb105442fbcbb359050182f988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cd4fcb105442fbcbb359050182f988">&#9670;&#160;</a></span>_sh_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * zll::_sh_pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d418476eff4046b39fc5d0335ff6693" name="a6d418476eff4046b39fc5d0335ff6693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d418476eff4046b39fc5d0335ff6693">&#9670;&#160;</a></span>detach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlink a node from existing list. </p>
<p >Previous or following node are linked together instead. Node itself does not keep any connections. </p>

</div>
</div>
<a id="a639d609c33a126597e38011900c08364" name="a639d609c33a126597e38011900c08364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639d609c33a126597e38011900c08364">&#9670;&#160;</a></span>detach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare &gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aee72801f82d0cebea0f695436f422f" name="a5aee72801f82d0cebea0f695436f422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aee72801f82d0cebea0f695436f422f">&#9670;&#160;</a></span>detach_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::detach_range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches subrange [first, last] from the list. </p>
<p >The range is not linked to any other node after detachment. Successor of <code>last</code> and predecessor of <code>first</code> are linked together. </p>

</div>
</div>
<a id="a4686b548a6c2812e4ee2e6f9ab3ab8fa" name="a4686b548a6c2812e4ee2e6f9ab3ab8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4686b548a6c2812e4ee2e6f9ab3ab8fa">&#9670;&#160;</a></span>detached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is detached from list. </p>

</div>
</div>
<a id="a1e5f7f94bac5fc728b19ee708f3fc2ff" name="a1e5f7f94bac5fc728b19ee708f3fc2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5f7f94bac5fc728b19ee708f3fc2ff">&#9670;&#160;</a></span>detached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc, Compare &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is detached from heap. </p>

</div>
</div>
<a id="aee0b9647befb868890b60caf39f3d293" name="aee0b9647befb868890b60caf39f3d293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0b9647befb868890b60caf39f3d293">&#9670;&#160;</a></span>detached_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zll::detached_range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the range is detached from list. </p>

</div>
</div>
<a id="a2ace8082eb072c3286742c3b17b825b9" name="a2ace8082eb072c3286742c3b17b825b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ace8082eb072c3286742c3b17b825b9">&#9670;&#160;</a></span>find_if_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * zll::find_if_node </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all nodes in the list starting from <code>n</code> until node for which <code>f</code> returns true is found. </p>
<p >Return pointer to such node, nullptr otherwise.</p>
<p >The order of the nodes is: predecessors, <code>n</code>, successors. </p>

</div>
</div>
<a id="a5b8723bf61a7e944036fb5dfce168d70" name="a5b8723bf61a7e944036fb5dfce168d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8723bf61a7e944036fb5dfce168d70">&#9670;&#160;</a></span>first_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::first_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over predecessors of node <code>n</code> and return the first node in the list. </p>

</div>
</div>
<a id="ab55da35af7a7e04b1898f7562f8274b7" name="ab55da35af7a7e04b1898f7562f8274b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55da35af7a7e04b1898f7562f8274b7">&#9670;&#160;</a></span>for_each_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::for_each_node </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all nodes in the list starting from <code>n</code> and call <code>f</code> for each node. </p>
<p >The order of the nodes is: predecessors, <code>n</code>, successors. </p>

</div>
</div>
<a id="a18cb8f77ce9ca47bc8d873ec2bda5a7a" name="a18cb8f77ce9ca47bc8d873ec2bda5a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cb8f77ce9ca47bc8d873ec2bda5a7a">&#9670;&#160;</a></span>inorder_traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::inorder_traverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71541bac40e1e9feef56f551b0bbe9ce" name="a71541bac40e1e9feef56f551b0bbe9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71541bac40e1e9feef56f551b0bbe9ce">&#9670;&#160;</a></span>last_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::last_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over successors of node <code>n</code> and return the last node in the list. </p>

</div>
</div>
<a id="a1d8e37f363fceef88778368b5d5dc860" name="a1d8e37f363fceef88778368b5d5dc860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8e37f363fceef88778368b5d5dc860">&#9670;&#160;</a></span>link_detached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad06c452ca25356a01e4ac1a88d341add" name="ad06c452ca25356a01e4ac1a88d341add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c452ca25356a01e4ac1a88d341add">&#9670;&#160;</a></span>link_detached_as_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_first </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> as first element of the list accessed by node <code>n</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a19c1bab91c3855c29f296a9899f43341" name="a19c1bab91c3855c29f296a9899f43341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c1bab91c3855c29f296a9899f43341">&#9670;&#160;</a></span>link_detached_as_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_last </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> as last element of the list accessed by node <code>n</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a528cd753e28cd0fab24c8ce781d7776c" name="a528cd753e28cd0fab24c8ce781d7776c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528cd753e28cd0fab24c8ce781d7776c">&#9670;&#160;</a></span>link_detached_as_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_next </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> after node <code>n</code>, any successor of <code>n</code> will be successor of <code>d</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="aaec58819ce3b46a79a6ba5beef9f2fc1" name="aaec58819ce3b46a79a6ba5beef9f2fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec58819ce3b46a79a6ba5beef9f2fc1">&#9670;&#160;</a></span>link_detached_as_prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_as_prev </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached node <code>d</code> before node <code>n</code>, any predecessor of <code>n</code> will be predecessor of <code>d</code>. </p>
<p >Undefined behavior if <code>d</code> is not detached. </p>

</div>
</div>
<a id="a3735f9abc58f2c4a5775a9ee0008df7e" name="a3735f9abc58f2c4a5775a9ee0008df7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3735f9abc58f2c4a5775a9ee0008df7e">&#9670;&#160;</a></span>link_detached_copy_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access, typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_detached_copy_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cpy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d848eba83fa0a8aa19aa4a6496328e" name="a60d848eba83fa0a8aa19aa4a6496328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d848eba83fa0a8aa19aa4a6496328e">&#9670;&#160;</a></span>link_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_group </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T * &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link nodes in <code>nodes</code> in order as successors of each other. </p>
<p >Undefined behavior if any of the nodes is not detached. </p>

</div>
</div>
<a id="abc80f9ef1f7cebd1cfb3d12751a72366" name="abc80f9ef1f7cebd1cfb3d12751a72366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc80f9ef1f7cebd1cfb3d12751a72366">&#9670;&#160;</a></span>link_range_as_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_range_as_next </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached range [first, last] as successor of node <code>n</code>. </p>
<p >Undefined behavior if sublist [first, last] is not detached. The range is linked as successor of <code>n</code> and the last element of the range is linked as predecessor of previous <code>n</code> successor. </p>

</div>
</div>
<a id="a86fc7485c5d05f2dc303cbb342d05eef" name="a86fc7485c5d05f2dc303cbb342d05eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fc7485c5d05f2dc303cbb342d05eef">&#9670;&#160;</a></span>link_range_as_prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::link_range_as_prev </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link detached range [first, last] as predecessor of node <code>n</code>. </p>
<p >Undefined behavior if sublist [first, last] is not detached. The range is linked as predecessor of <code>n</code> and the first element of the range is linked as successor of previous <code>n</code> predecessor. </p>

</div>
</div>
<a id="a42243d44581d8f0ee1e9c18d4acf2184" name="a42243d44581d8f0ee1e9c18d4acf2184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42243d44581d8f0ee1e9c18d4acf2184">&#9670;&#160;</a></span>merge_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T *, T * &gt; zll::merge_ranges </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge two ranges [lhf, lhl] and [rhf, rhl] into one range. </p>
<p >Uses <code>comp</code> to determine the order of the elements in the resulting range. Pointers to the first and last elements of the resulting range are returned. </p>

</div>
</div>
<a id="a144697c395d7e039e0aca2a585fbe792" name="a144697c395d7e039e0aca2a585fbe792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144697c395d7e039e0aca2a585fbe792">&#9670;&#160;</a></span>move_from_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::move_from_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links predecessor and successor of <code>from</code> node as predecessor and successor of <code>to</code> node. </p>
<p >Can be used to implement move semantics of custom nodes. Undefined behavior if <code>to</code> is not detached. </p>

</div>
</div>
<a id="a24b2449a29846b12ecb477ed4a52f8f0" name="a24b2449a29846b12ecb477ed4a52f8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b2449a29846b12ecb477ed4a52f8f0">&#9670;&#160;</a></span>move_from_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::move_from_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8daf6432db70018790a23a5b9bad24a6" name="a8daf6432db70018790a23a5b9bad24a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daf6432db70018790a23a5b9bad24a6">&#9670;&#160;</a></span>postorder_traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::postorder_traverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73348745e5791eb7557fd8367a7e14ff" name="a73348745e5791eb7557fd8367a7e14ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73348745e5791eb7557fd8367a7e14ff">&#9670;&#160;</a></span>preorder_traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::preorder_traverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::invocable&lt; T &amp; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ccc5e1d745179f3326f0ff913454176" name="a1ccc5e1d745179f3326f0ff913454176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccc5e1d745179f3326f0ff913454176">&#9670;&#160;</a></span>range_qsort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Compare  = std::less&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::range_qsort </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>std::less&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the range [first, last] using quicksort algorithm. The <code>cmp</code> is used to compare two nodes. </p>

</div>
</div>
<a id="a4bd2dd1625cac198e1fc0e293555e9f0" name="a4bd2dd1625cac198e1fc0e293555e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd2dd1625cac198e1fc0e293555e9f0">&#9670;&#160;</a></span>range_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename Pred &gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t zll::range_remove </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes in the range [first, last] for which <code>p</code> returns true. </p>
<p >Returns the number of removed nodes. </p>

</div>
</div>
<a id="a34016023d1d718ae8bfb47426a3a7c39" name="a34016023d1d718ae8bfb47426a3a7c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34016023d1d718ae8bfb47426a3a7c39">&#9670;&#160;</a></span>range_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zll::range_reverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse order of nodes in the range [first, last]. </p>
<p >The first node in the range will become the last node and the last node will become the first node. </p>

</div>
</div>
<a id="a0f5d6a98fc40a5b09ff7b6db2f55dff5" name="a0f5d6a98fc40a5b09ff7b6db2f55dff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5d6a98fc40a5b09ff7b6db2f55dff5">&#9670;&#160;</a></span>range_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc , typename BinPred  = std::equal_to&lt;&gt;&gt; <br />
requires ( _provides_ll_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t zll::range_unique </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinPred &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em> = <code>std::equal_to&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all consecutive nodes in the range [first, last] for which <code>p</code> returns true. </p>
<p >Only first element in each group of equal elements is left. </p>

</div>
</div>
<a id="a71983897a243ee29a1a0d1ce5f1ad236" name="a71983897a243ee29a1a0d1ce5f1ad236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71983897a243ee29a1a0d1ce5f1ad236">&#9670;&#160;</a></span>top_node_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Acc  = typename T::access&gt; <br />
requires ( _provides_sh_header&lt; T, Acc &gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; zll::top_node_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacezll.html">zll</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
